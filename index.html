<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sz√≥da</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@300;400&display=swap');

        :root {
            --dark-blue: #0f172a; --mid-blue: #1e293b; --light-blue-text: #e0f7fa;
            --neon-cyan: #00bfff; --neon-green: #4ade80; --neon-amber: #f59e0b;
            --neon-purple: #c084fc;
        }

        body {
            font-family: 'Roboto', sans-serif; background-color: var(--dark-blue);
            color: var(--light-blue-text); text-align: center; margin: 0; padding: 20px;
            -webkit-tap-highlight-color: transparent;
        }
        
        #main-content { opacity: 0; transition: opacity 1s ease-in; }

        #game-layout {
            display: flex;
            justify-content: center;
            align-items: stretch; 
            gap: 30px;
            max-width: 1400px;
            margin: auto;
        }
        #left-column, #right-column { width: 280px; display: flex; flex-direction: column; flex-shrink: 0; }
        #center-column { display: flex; flex-direction: column; align-items: center; flex-shrink: 0; }
        
        #logo-container { position: relative; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 15px; }
        .logo-text { font-family: 'Orbitron', sans-serif; font-size: 5em; font-weight: bold; color: #ffffff; text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan); }
        
        #champion-trophy {
            display: none;
            font-size: 3em;
            filter: drop-shadow(0 0 10px var(--neon-amber));
        }

        .static-bubble {
            position: absolute; border-radius: 50%; background: rgba(0, 191, 255, 0.2);
            box-shadow: inset 0 0 10px rgba(255,255,255,0.5); z-index: -1;
            animation: fizz 6s ease-in-out infinite;
        }
        
        .sb1 { width: 50px; height: 50px; top: -10px; left: -30px; animation-delay: 0s; }
        .sb2 { width: 30px; height: 30px; top: 60%; right: -40px; animation-delay: -1.5s; }
        .sb3 { width: 60px; height: 60px; bottom: -20px; right: 50px; animation-delay: -3s; }
        .sb4 { width: 20px; height: 20px; bottom: 0; left: 20px; animation-delay: -4.5s; }

        @keyframes fizz {
            0% { transform: translateY(0) scale(1); opacity: 0.7; }
            25% { transform: translateY(-5px) scale(1.05); opacity: 0.5; }
            50% { transform: translateY(0) scale(0.95); opacity: 0.9; }
            75% { transform: translateY(5px) scale(1); opacity: 0.6; }
            100% { transform: translateY(0) scale(1); opacity: 0.7; }
        }

        .panel {
            padding: 20px; background-color: rgba(15, 23, 42, 0.8);
            border-radius: 8px; border: 1px solid rgba(0, 191, 255, 0.3);
            display: flex; flex-direction: column; position: relative; width: 100%; box-sizing: border-box;
            flex-grow: 1;
        }
        .panel-inner { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        .panel::before, .panel::after, .panel-inner::before, .panel-inner::after {
            content: ''; position: absolute; width: 15px; height: 15px;
            border-color: var(--neon-cyan); border-style: solid; opacity: 0.7;
        }
        .panel::before { top: 8px; left: 8px; border-width: 2px 0 0 2px; }
        .panel::after { top: 8px; right: 8px; border-width: 2px 2px 0 0; }
        .panel-inner::before { bottom: 8px; left: 8px; border-width: 0 0 2px 2px; }
        .panel-inner::after { bottom: 8px; right: 8px; border-width: 0 2px 2px 0; }

        #word-list-container h3, #rewards-container h3 { font-family: 'Orbitron', sans-serif; margin-top: 0; color: var(--neon-cyan); text-shadow: 0 0 5px var(--neon-cyan); }
        #level-display { font-family: 'Orbitron', sans-serif; margin-top: -10px; margin-bottom: 10px; color: var(--neon-amber); min-height: 1.2em; }
        #timer-container { min-height: 60px; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; }
        #timer-display { font-family: 'Orbitron', sans-serif; font-size: 1.2em; color: var(--light-blue-text); text-shadow: 0 0 5px var(--neon-cyan); margin-bottom: 5px; }
        #timer-display.warmup-round { color: var(--neon-amber); }
        
        #new-board-btn { display: none; padding: 15px 30px; font-size: 1.2em; font-family: 'Orbitron', sans-serif; cursor: pointer; color: white; background: linear-gradient(45deg, var(--neon-green), #22c55e); border: none; border-radius: 5px; }

        #end-round-choices { display: none; gap: 10px; }
        .choice-btn { flex: 1; padding: 10px; font-family: 'Orbitron', sans-serif; font-size: 0.9em; border-radius: 5px; border: none; cursor: pointer; color: white; }
        #btn-cash-in { background: linear-gradient(45deg, var(--neon-green), #22c55e); }
        #btn-risk-it { background: linear-gradient(45deg, var(--neon-amber), #e18c41); }

        #words, #sprint-words-list {
            list-style: none; padding: 0; margin: 0;
            flex-grow: 1;
            column-count: 2;
            column-gap: 20px;
        }
        #words li, #sprint-words-list li { 
            padding: 5px; 
            margin-bottom: 5px; 
            font-size: 1.1em; 
            border-radius: 5px; 
            transition: all 0.3s ease; 
            text-align: left;
            -webkit-column-break-inside: avoid;
            page-break-inside: avoid;
            break-inside: avoid;
        }
        #words li.hidden-word { display: none; }
        #words li.found { 
            background: rgba(74, 222, 128, 0.2); 
            color: #a7f3d0;
            text-decoration: line-through;
            text-decoration-thickness: 2px;
            font-style: italic;
        }
        #words li .revealed-letter {
            color: var(--neon-amber);
            font-weight: bold;
        }
        #sprint-words-list li { text-decoration: none; font-style: normal; background: rgba(0, 191, 255, 0.1); }
        
        #rewards-list, #piac-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #piac-list { display: none; }
        
        .panel-bottom-section { margin-top: auto; padding-top: 15px; }
        #solution-container { margin-bottom: 15px; }
        #megoldas-btn {
            display: none; padding: 10px 20px; font-size: 1.1em;
            font-family: 'Orbitron', sans-serif; cursor: pointer; color: white;
            background: linear-gradient(45deg, var(--neon-amber), #e18c41);
            border: none; border-radius: 5px; width: 100%;
        }
        #megoldas-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        #score-container { text-align: center; flex-shrink: 0; position: relative; }
        #score { font-size: 2.5em; color: var(--neon-amber); font-weight: bold; }

        #multiplier-display { 
            display: none; 
            position: absolute; top: 0; right: 0; 
            background-color: var(--neon-amber); color: var(--dark-blue); 
            font-family: 'Orbitron', sans-serif; font-weight: bold;
            padding: 2px 6px; border-radius: 4px; font-size: 0.8em;
        }
        
        #sprint-container { display: none; flex-direction: column; flex-grow: 1; }
        #sprint-score-container { text-align: center; margin-top: auto; padding-top: 15px; }
        #sprint-score { font-size: 1.5em; color: var(--neon-cyan); font-weight: bold; }
        
        #grid-container {
            display: grid; grid-template-columns: repeat(9, 60px);
            gap: 5px; padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 191, 255, 0.5);
            touch-action: none;
        }
        .grid-cell {
            width: 60px; height: 60px; display: flex; justify-content: center; align-items: center;
            background-color: var(--mid-blue); color: var(--light-blue-text);
            cursor: pointer; font-size: 2.5em; font-weight: bold; text-transform: uppercase;
            user-select: none; border-radius: 5px; transition: all 0.2s ease;
            position: relative;
        }
        .grid-cell.hint-found { background-color: #0c4a6e; color: #7dd3fc; box-shadow: 0 0 15px var(--neon-cyan); cursor: not-allowed; }
        .grid-cell.selected { background-color: var(--neon-amber); color: var(--mid-blue); box-shadow: 0 0 15px var(--neon-amber); transform: scale(1.05); }
        
        .grid-cell.bonus-dp { background-color: #4a330c; color: var(--neon-amber); box-shadow: 0 0 15px var(--neon-amber); }
        .grid-cell.bonus-time { background-color: #0c4a2e; color: var(--neon-green); box-shadow: 0 0 15px var(--neon-green); }

        .grid-cell.soda-sense-glow {
            animation: soda-glow 1.5s infinite alternate;
        }
        @keyframes soda-glow {
            from { box-shadow: 0 0 5px rgba(0, 191, 255, 0.2); }
            to { box-shadow: 0 0 15px rgba(0, 191, 255, 0.7), 0 0 5px rgba(0, 191, 255, 0.7) inset; }
        }

        .hidden-bubble-icon {
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.4) 0%, rgba(0, 191, 255, 0.1) 70%);
            border-radius: 50%;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #current-word-container { display: flex; align-items: center; justify-content: center; margin-top: 15px; height: 50px; gap: 10px;}
        #current-word-preview {
            font-size: 2em; color: var(--neon-amber); letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif; text-transform: uppercase;
            flex-grow: 1; text-align: center;
        }
        #clear-selection-btn, #undo-selection-btn {
            display: none; padding: 8px 15px; font-size: 0.9em;
            font-family: 'Orbitron', sans-serif; cursor: pointer; border: none; border-radius: 5px;
        }
        #clear-selection-btn {
             color: var(--dark-blue); background: var(--neon-amber);
        }
        #undo-selection-btn {
             color: var(--dark-blue); background: var(--neon-cyan);
        }

        .reward-item {
            background-color: var(--mid-blue); border: 1px solid #334155;
            padding: 15px; margin-bottom: 12px;
            border-radius: 5px; cursor: pointer; transition: all 0.2s; text-align: left;
        }
        .reward-item.disabled { opacity: 0.4; cursor: not-allowed; }
        .reward-item.affordable {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan), 0 0 5px var(--neon-cyan) inset;
        }
        .piac-item.affordable {
            border-color: var(--neon-purple);
            box-shadow: 0 0 15px var(--neon-purple), 0 0 5px var(--neon-purple) inset;
        }
        .reward-name { font-weight: bold; font-size: 1.1em; color: #93c5fd; }
        .reward-desc { font-size: 0.8em; margin: 5px 0; color: #94a3b8; }
        .reward-cost { font-weight: bold; color: var(--neon-amber); text-align: right; }
        .piac-cost { font-weight: bold; color: var(--neon-purple); text-align: right; }

        #copyright { font-size: 0.9em; color: #64748b; margin-top: -10px; margin-bottom: 20px; }

        #rules-container { max-width: 800px; margin: 40px auto 0 auto; text-align: left; }
        #rules-container h2 { font-family: 'Orbitron', sans-serif; color: var(--neon-cyan); text-align: center; }
        #rules-container ul { list-style: none; padding-left: 0; }
        #rules-container li { margin-bottom: 15px; padding-left: 25px; position: relative; }
        #rules-container li::before { content: '>'; position: absolute; left: 0; color: var(--neon-cyan); font-weight: bold; }

        #soda-hunt-container { border-top: 1px solid rgba(0, 191, 255, 0.3); margin-top: 15px; padding-top: 15px; }
        #soda-hunt-letters { display: flex; justify-content: space-around; font-family: 'Orbitron', sans-serif; font-size: 2em; }
        #soda-hunt-letters span { color: #475569; transition: all 0.3s ease-in-out; }
        #soda-hunt-letters span.collected { color: var(--neon-cyan); text-shadow: 0 0 10px var(--neon-cyan); transform: scale(1.2); }
        #soda-hunt-claim-btn { display: none; width: 100%; margin-top: 10px; padding: 10px; font-family: 'Orbitron', sans-serif; font-size: 1.2em; background: linear-gradient(45deg, var(--neon-purple), #9333ea); color: white; border: none; border-radius: 5px; cursor: pointer; }
        #active-powerup-display { font-size: 0.8em; color: var(--neon-green); margin-top: 10px; height: 20px;}
        
        #soda-penz-display { text-align: center; padding: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(0, 191, 255, 0.3); }
        #soda-penz-balance { font-family: 'Orbitron', sans-serif; font-size: 1.8em; color: var(--neon-purple); text-shadow: 0 0 8px var(--neon-purple); }
        .shop-tabs { display: flex; border-bottom: 1px solid rgba(0, 191, 255, 0.3); margin-bottom: 15px; }
        .tab-btn { flex: 1; padding: 10px; background: none; border: none; color: #64748b; font-family: 'Orbitron', sans-serif; cursor: pointer; transition: all 0.2s; }
        .tab-btn.active { color: var(--neon-cyan); background: rgba(0, 191, 255, 0.1); border-bottom: 2px solid var(--neon-cyan); }


        @media (max-width: 900px) {
            body { padding: 10px 5px; }
            #game-layout { flex-direction: column; align-items: center; gap: 25px; }
            #left-column, #right-column, #center-column { width: 100%; max-width: 480px; }
            #center-column { order: 1; }
            #left-column { order: 2; }
            #right-column { order: 3; }
            .logo-text { font-size: 3.5em; }
            #grid-container { width: 95vw; max-width: 480px; height: 95vw; max-height: 480px; grid-template-columns: repeat(9, 1fr); gap: 1.1vw; padding: 1.5vw; }
            .grid-cell { font-size: clamp(14px, 5.5vw, 30px); border-radius: 1vw; }
            #current-word-container { height: 40px; }
            #current-word-preview { font-size: 1.5em; }
            #words li { font-size: 1.1em; padding: 6px 8px;}
            #clear-selection-btn, #undo-selection-btn { display: block; }
            #words, #sprint-words-list { column-count: 1; max-height: 25vh; overflow-y: auto; }
            #rewards-list, #piac-list { max-height: 25vh; }
        }
    </style>
</head>
<body>
    <div id="main-content">
        <div id="game-layout">
            <div id="left-column">
                <div id="word-list-container" class="panel">
                    <div class="panel-inner">
                        <div id="timer-container">
                            <div id="timer-display"></div>
                            <button id="new-board-btn">Kezd≈ëdj√∂n az √©les j√°t√©k!</button>
                            <div id="end-round-choices">
                                <button id="btn-cash-in" class="choice-btn">Bev√°ltom</button>
                                <button id="btn-risk-it" class="choice-btn">Kock√°ztatok!</button>
                            </div>
                        </div>
                        <div id="level-display"></div>
                        <div id="sprint-container">
                             <h3>SPRINT SZAVAK</h3>
                             <ul id="sprint-words-list"></ul>
                        </div>
                        <h3 id="words-title">KERESEND≈ê SZAVAK</h3>
                        <ul id="words"></ul>
                        <div class="panel-bottom-section">
                            <div id="sprint-score-container">
                                <h3>SPRINT PONTOK</h3>
                                <div id="sprint-score">0</div>
                            </div>
                            <div id="solution-container">
                                <button id="megoldas-btn">Megold√°s Felfed√©se</button>
                            </div>
                            <div id="score-container">
                                <h3>PONTOK</h3>
                                <div id="score">0</div>
                                <div id="multiplier-display">2x</div>
                            </div>
                            <div id="soda-hunt-container">
                                <h3>SZ√ìDA-VAD√ÅSZAT</h3>
                                <div id="soda-hunt-letters">
                                    <span data-letter="SZ">SZ</span>
                                    <span data-letter="√ì">√ì</span>
                                    <span data-letter="D">D</span>
                                    <span data-letter="A">A</span>
                                </div>
                                <div id="active-powerup-display"></div>
                                <button id="soda-hunt-claim-btn">BEV√ÅLT√ÅS</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="center-column">
                <div id="logo-container">
                    <span id="champion-trophy">üèÜ</span>
                    <div class="logo-text">Sz√≥da</div>
                    <div class="static-bubble sb1"></div><div class="static-bubble sb2"></div>
                    <div class="static-bubble sb3"></div><div class="static-bubble sb4"></div>
                </div>
                <div id="copyright">Copyright ¬© by: Robi</div>
                <div id="grid-container"></div>
                <div id="current-word-container">
                    <button id="undo-selection-btn">Vissza</button>
                    <div id="current-word-preview"></div>
                    <button id="clear-selection-btn">T√∂rl√©s</button>
                </div>
            </div>
            <div id="right-column">
                <div id="rewards-container" class="panel">
                    <div class="panel-inner">
                        <div id="soda-penz-display">
                            <h3>SZ√ìDA-P√âNZ</h3>
                            <div id="soda-penz-balance">0</div>
                        </div>
                        <div class="shop-tabs">
                            <button id="tab-nyeremeny" class="tab-btn active">Nyerem√©nybolt</button>
                            <button id="tab-piac" class="tab-btn">Sz√≥da-Piac</button>
                        </div>
                        <div id="rewards-list"></div>
                        <div id="piac-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="rules-container" class="panel">
        <div class="panel-inner">
            <h2>J√°t√©kszab√°lyzat</h2>
            <ul>
                <li><strong>A C√©l:</strong> K√ºzdd fel magad a Bajnoki L√©tr√°n √©s nyerd el a Sz√≥da Bajnoka c√≠met!</li>
                <li><strong>Bemeleg√≠t≈ë K√∂r:</strong> Ha egy 6 perces ciklus k√∂zep√©n √©rkezel, egy t√©t n√©lk√ºli k√∂rben (16 sz√≥) gyakorolhatsz a k√∂vetkez≈ë teljes k√∂r kezdet√©ig. Itt a pontok √©s b√≥nuszok nem sz√°m√≠tanak.</li>
                <li><strong>√âles K√∂r√∂k & Bajnoki L√©tra:</strong> A teljes 6 perces k√∂r√∂k "√©lesben" mennek. A l√©tra 5 szintb≈ël √°ll, egyre t√∂bb sz√≥val: 1. szint (18 sz√≥), 2. szint (20), 3. szint (22), 4. szint (24), v√©g√ºl az 5. szint, a Bajnoki K√∂r (30 sz√≥).</li>
                <li><strong>Kock√°ztass vagy Gy≈±jts:</strong> Ha teljes√≠tesz egy szintet, d√∂nthetsz: a pontjaidat biztons√°gban Sz√≥da-P√©nzre v√°ltod (de a l√©tr√°t el√∂lr≈ël kezded), vagy kock√°ztatsz egy <strong>2x pontszorz√≥√©rt</strong> a k√∂vetkez≈ë, nehezebb szinten. De vigy√°zz, ha a b√≥nusz k√∂rben nem tal√°lsz meg minden sz√≥t, a t√©tk√©nt vitt pontjaid elvesznek √©s a l√©tra elej√©re ker√ºlsz!</li>
                <li><strong>Bajnoki K√∂r (5. szint):</strong> A v√©gs≈ë kih√≠v√°s! Itt a 30 sz√≥ egyes√©vel jelenik meg a list√°n. Ha 6 perc alatt teljes√≠ted, egy h√©tig ti√©d a Bajnoki Serleg!</li>
                <li><strong>Sz√≥da Sprint:</strong> Ha egy √©les k√∂rben az id≈ë lej√°rta el≈ëtt megtal√°lod az √∂sszes sz√≥t, elindul a Sprint! A h√°tral√©v≈ë id≈ëben keress b√°rmilyen magyar sz√≥t a t√°bl√°n extra Sz√≥da-P√©nz√©rt!</li>
                <li><strong>B√≥nuszok & Piac:</strong> Haszn√°ld a pontjaidat √©s a Sz√≥da-P√©nzedet, hogy seg√≠ts√©geket √©s maradand√≥ fejleszt√©seket v√°s√°rolj!</li>
            </ul>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
    // WORD LIST - JAV√çT√ÅS: Jelent≈ësen b≈ëv√≠tett lista
    const hungarianWords = [
        'ablak', 'asztal', 'aut√≥', 'ban√°n', 'bicikli', 'cica', 'citrom', 'csillag', 'dinnye', 'di√≥',
        'elef√°nt', 'eper', 'erd≈ë', 'fal', 'fa', 'felh≈ë', 'foly√≥', 'f≈±', 'git√°r', 'gomb', 'gomba', 'gyerek',
        'gy√ºm√∂lcs', 'haj√≥', 'hal', 'h√°z', 'hegy', 'h√≠d', 'h√≥', 'hold', 'homok', 'iskola', 'j√°t√©k', 'kacsa',
        'kalap', 'kapa', 'kapu', 'kert', 'keszty≈±', 'k√≠gy√≥', 'kilincs', 'kir√°ly', 'kocsi', 'kors√≥', 'k√∫t',
        'kutya', 'k√∂nyv', 'k√∂rte', 'labda', 'l√°b', 'l√°mpa', 'l√©tra', 'l√≥', 'macska', 'mad√°r', 'm√°lna',
        'medve', 'm√©z', 'm√≥kus', 'motor', 'nap', 'nadr√°g', 'narancs', 'ny√∫l', 'oll√≥', '√≥ra', 'oroszl√°n',
        'pad', 'pap√≠r', 'paradicsom', 'p√°rna', 'p√©nz', 'pillang√≥', 'poh√°r', 'polc', 'pul√≥ver', 'r√°di√≥',
        'rep√ºl≈ë', 'r√≥ka', 'sapka', 's√°rk√°ny', 's√°tor', 'sonka', 's√≥', 'sz√©k', 'szekr√©ny', 'szem', 'sziget',
        'szilva', 'sz≈ël≈ë', 'sz≈ënyeg', 't√°l', 't√°ska', 'telefon', 't√©l', 'telev√≠zi√≥', 'tenger', 't√©rk√©p',
        'tigris', 't√≥', 'toj√°s', 't√ºk√∂r', 't≈±', 't≈±z', 'uborka', 'udvar', 'ujs√°g', '√ºveg', '≈±rhaj√≥',
        'vasal√≥', 'v√°za', 'verseny', 'villa', 'vir√°g', 'v√≠z', 'vonat', 'v√∂d√∂r', 'zene', 'zongora',
        'zebra', 'z√∂lds√©g', 'z√°szl√≥', 'zokni', '√°gy', '√°rv√≠z', '√°s√≥', 'csavar', 'cs√©sze', 'csoki',
        'cs√≥nak', 'doboz', 'dzseki', 'ecset', 'ed√©ny', 'eg√©r', '√©jjel', 'erd√©sz', 'ez√ºst', 'fest√©k',
        'f√©s≈±', 'fi√≥k', 'f√ºrd≈ë', 'f√ºl', 'gar√°zs', 'g√©p', 'goly√≥', 'haj', 'harang', 'heged≈±',
        'h√©tf≈ë', 'hinta', 'h√∫s', 'iker', 'ing', 'isten', '√≠v', 'joghurt', 'k√°d', 'k√°v√©',
        'kefe', 'keny√©r', 'k√©p', 'ker√©k', 'korona', 'k≈ë', 'kulcs', 'l√°ny', 'lev√©l', 'lufi',
        'mez≈ë', 'mikrofon', 'mozi', 'munk√°s', 'nyak', 'ny√°r', 'olaj', 'orvos', '√∂v', '≈ëz', 'papucs',
        'park', 'posta', 'p√≥k', 'robot', 'ruha', 'sajt', 's√°l', 'serpeny≈ë', 'sport', 'sz√°j',
        'szalv√©ta', 'szappan', 'sz√©l', 'szem√ºveg', 'sz√≠v', 'szoknya', 'takar√≥', 't√°ny√©r', 'tea',
        'tej', 't√©szta', 'toll', 'torta', 't√∂r√∂lk√∂z≈ë', 'ujj', 'utca', 'v√°ll', 'v√°r', 'vas√∫t', 'vihar',
        'vill√°m', 'zab', 'zivatar', 'zsir√°f', 'zs√°k', 'pap', 'sas', 't√©lap√≥', 'h√°bor√∫', 'b√©ke', 'szabads√°g',
        'szeretet', '√∂r√∂m', 'b√°nat', '√©let', 'hal√°l', 'tavasz', '≈ësz', 't≈±zolt√≥', 'rend≈ër', 'k√≥rh√°z',
        'egyetem', 'f≈ëiskola', 'tan√°r', 'di√°k', 'sz√°m√≠t√≥g√©p', 'internet', 'program', 'k√≥d', 'j√°t√©kos'
    ];
    const fullWordSet = new Set(hungarianWords.map(w => w.toUpperCase()));

    // DOM Elements
    const gridContainer = document.getElementById('grid-container');
    const wordListElement = document.getElementById('words');
    const scoreElement = document.getElementById('score');
    const currentWordPreview = document.getElementById('current-word-preview');
    const clearSelectionBtn = document.getElementById('clear-selection-btn');
    const undoSelectionBtn = document.getElementById('undo-selection-btn');
    const megoldasBtn = document.getElementById('megoldas-btn');
    const timerDisplay = document.getElementById('timer-display');
    const newBoardBtn = document.getElementById('new-board-btn');
    const sodaPenzBalanceElement = document.getElementById('soda-penz-balance');
    const rewardsListElement = document.getElementById('rewards-list');
    const piacListElement = document.getElementById('piac-list');
    const tabNyeremeny = document.getElementById('tab-nyeremeny');
    const tabPiac = document.getElementById('tab-piac');
    const multiplierDisplay = document.getElementById('multiplier-display');
    const levelDisplay = document.getElementById('level-display');
    const endRoundChoices = document.getElementById('end-round-choices');
    const btnCashIn = document.getElementById('btn-cash-in');
    const btnRiskIt = document.getElementById('btn-risk-it');
    const championTrophy = document.getElementById('champion-trophy');
    const sodaHuntLetters = document.getElementById('soda-hunt-letters').children;
    const sodaHuntClaimBtn = document.getElementById('soda-hunt-claim-btn');
    const activePowerupDisplay = document.getElementById('active-powerup-display');
    const sprintContainer = document.getElementById('sprint-container');
    const sprintScoreElement = document.getElementById('sprint-score');
    const wordsTitle = document.getElementById('words-title');
    const sprintWordsList = document.getElementById('sprint-words-list');
    
    // Game Constants
    const GRID_SIZE = 9;
    const CYCLE_MINUTES = 6;
    const LADDER_WORD_COUNTS = [18, 20, 22, 24, 30];
    const WARMUP_WORD_COUNT = 16;

    // Game State
    let grid = [];
    let wordsToFind = [];
    let wordLocations = new Map();
    let foundWords = new Set();
    let selectedCells = [];
    let isSelecting = false;
    let currentScore = 0;
    let nextBoardDate;
    let isWarmupRound = false;
    let isGameActive = false; 
    let WORD_COUNT;
    let isRisking = false;
    let riskedScore = 0;
    let isSprintMode = false;
    let sprintScore = 0;
    let sprintFoundWords = new Set();
    let collectedSodaLetters = new Set();
    let activePowerUp = { type: null, timer: null };
    let roundWon = false; // √öJ V√ÅLTOZ√ì a gy≈ëzelem √°llapot√°nak t√°rol√°s√°ra

    let gameState = {
        sodaPenz: 0,
        ladderLevel: 1,
        upgrades: {
            point_multiplier: 0,
            soda_penz_multiplier: 0,
            bonus_chance: 0,
            starting_hint: 0,
        },
        championUntil: null
    };

    const REWARDS = {
        'reveal_letter': { name: 'Bet≈± Felfed√©s', desc: 'Megmutatja egy v√©letlenszer≈±, m√©g meg nem tal√°lt sz√≥ els≈ë bet≈±j√©t a list√°n.', cost: 750, type: 'point' },
        'hint': { name: 'Teljes Seg√≠ts√©g', desc: 'Felfed egy komplett, m√©g meg nem tal√°lt sz√≥t a t√°bl√°n.', cost: 2000, type: 'point' },
        'soda_sense': { name: 'Sz√≥da-√ârz√©k (20 mp)', desc: '20 m√°sodpercre halv√°nyan f√©nyleni kezdenek a megold√°shoz tartoz√≥ bet≈±k.', cost: 6000, type: 'point' },
        'sprint_start': { name: 'Azonnali Sprint', desc: 'Azonnal elind√≠tja a Sprint m√≥dot 30 m√°sodperccel. K√∂r√∂nk√©nt egyszer haszn√°lhat√≥.', cost: 8000, type: 'point', used: false },
    };
    
    const PIAC_ITEMS = {
        'point_multiplier': { name: 'Pontszorz√≥ Fejleszt√©s', desc: 'V√©glegesen n√∂veli a szavak √©rt√©k√©t 5%-kal szintenk√©nt.', cost: 150, type: 'soda', maxLevel: 10 },
        'soda_penz_multiplier': { name: 'Sz√≥da-P√©nz Szorz√≥', desc: 'V√©glegesen n√∂veli a k√∂r v√©g√©n kapott Sz√≥da-P√©nzt 5%-kal szintenk√©nt.', cost: 300, type: 'soda', maxLevel: 10 },
        'bonus_chance': { name: 'B√≥nusz Es√©ly N√∂vel√©s', desc: 'V√©glegesen n√∂veli a b√≥nusz mez≈ëk (Pont, Id≈ë) megjelen√©s√©nek es√©ly√©t.', cost: 400, type: 'soda', maxLevel: 5 },
        'starting_hint': { name: 'Kezd≈ë Seg√≠ts√©g', desc: 'Minden √©les k√∂r egy m√°r felfedett sz√≥val kezd≈ëdik. Egyszeri v√©tel.', cost: 2500, type: 'soda', maxLevel: 1 },
    };

    // --- Game Logic ---

    function saveGameState() {
        localStorage.setItem('szodaGameState', JSON.stringify(gameState));
    }

    function loadGameState() {
        const savedState = localStorage.getItem('szodaGameState');
        if (savedState) {
            const loaded = JSON.parse(savedState);
            gameState = { ...gameState, ...loaded, upgrades: { ...gameState.upgrades, ...loaded.upgrades } };
        }
        updateSodaPenzUI();
        updatePiacUI();
        checkChampionStatus();
    }

    function checkChampionStatus() {
        if (gameState.championUntil) {
            const now = new Date().getTime();
            if (now < gameState.championUntil) {
                championTrophy.style.display = 'inline';
            } else {
                gameState.championUntil = null;
                championTrophy.style.display = 'none';
                saveGameState();
            }
        }
    }
    
    function generateGrid() {
        let success = false;
        while (!success) {
            wordsToFind = [...hungarianWords].sort(() => 0.5 - Math.random()).slice(0, WORD_COUNT).map(w => w.toUpperCase());
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null).map(() => ({ letter: '', bonus: null, hiddenLetter: null })));
            wordLocations.clear();
            success = placeAllWords();
        }

        if (!isWarmupRound) {
            placeBonuses('dp', 1 + Math.floor(gameState.ladderLevel / 2));
            placeBonuses('time', 1 + Math.floor(gameState.ladderLevel / 3));
            placeSodaLetters();
        }

        const alphabet = "A√ÅBCDE√âFGHI√çJKLMNO√ì√ñ≈êPQRSTU√ö√ú≈∞VWXYZ";
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (!grid[r][c].letter) {
                    grid[r][c].letter = alphabet[Math.floor(Math.random() * alphabet.length)];
                }
            }
        }
    }

    function placeAllWords() {
        const directions = [
            { r: 0, c: 1 }, { r: 1, c: 0 }, { r: 0, c: -1 }, { r: -1, c: 0 }
        ];

        for (const word of wordsToFind) {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 200) {
                const dir = directions[Math.floor(Math.random() * directions.length)];
                const startRow = Math.floor(Math.random() * GRID_SIZE);
                const startCol = Math.floor(Math.random() * GRID_SIZE);

                if (canPlaceWord(word, startRow, startCol, dir)) {
                    placeWord(word, startRow, startCol, dir);
                    placed = true;
                }
                attempts++;
            }
            if (!placed) return false;
        }
        return true;
    }

    function canPlaceWord(word, r, c, dir) {
        for (let i = 0; i < word.length; i++) {
            const newRow = r + i * dir.r;
            const newCol = c + i * dir.c;
            if (newRow < 0 || newRow >= GRID_SIZE || newCol < 0 || newCol >= GRID_SIZE) {
                return false;
            }
            const existingLetter = grid[newRow][newCol].letter;
            if (existingLetter && existingLetter !== word[i]) {
                return false;
            }
        }
        return true;
    }

    function placeWord(word, r, c, dir) {
        const locations = [];
        for (let i = 0; i < word.length; i++) {
            const newRow = r + i * dir.r;
            const newCol = c + i * dir.c;
            grid[newRow][newCol].letter = word[i];
            locations.push({ r: newRow, c: newCol });
        }
        wordLocations.set(word, locations);
    }

    function placeBonuses(type, count) {
        const bonusLevel = gameState.upgrades.bonus_chance || 0;
        const totalCount = count + bonusLevel;
        let placed = 0;
        let attempts = 0;
        while(placed < totalCount && attempts < 100) {
            const r = Math.floor(Math.random() * GRID_SIZE);
            const c = Math.floor(Math.random() * GRID_SIZE);
            if(!grid[r][c].bonus && !grid[r][c].hiddenLetter) {
                grid[r][c].bonus = type;
                placed++;
            }
            attempts++;
        }
    }

    function placeSodaLetters() {
        const lettersToPlace = ['SZ', '√ì', 'D', 'A'].filter(l => !collectedSodaLetters.has(l));
        let placedCount = 0;
        let attempts = 0;
        while(placedCount < lettersToPlace.length && attempts < 100) {
            const r = Math.floor(Math.random() * GRID_SIZE);
            const c = Math.floor(Math.random() * GRID_SIZE);
            if(!grid[r][c].bonus && !grid[r][c].hiddenLetter) {
                grid[r][c].hiddenLetter = lettersToPlace[placedCount];
                placedCount++;
            }
            attempts++;
        }
    }

    function drawGrid() {
        gridContainer.innerHTML = '';
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.row = r;
                cell.dataset.col = c;
                
                const cellData = grid[r][c];
                cell.textContent = cellData.letter;

                if(cellData.bonus === 'dp') cell.classList.add('bonus-dp');
                if(cellData.bonus === 'time') cell.classList.add('bonus-time');

                if(cellData.hiddenLetter) {
                     const icon = document.createElement('div');
                     icon.className = 'hidden-bubble-icon';
                     cell.appendChild(icon);
                }

                gridContainer.appendChild(cell);
            }
        }
    }

    function startNewRound(isWarmup) {
        gridContainer.style.pointerEvents = 'auto';
        isGameActive = true;
        isWarmupRound = isWarmup;
        isSprintMode = false;
        roundWon = false; // JAV√çT√ÅS: Gy≈ëzelem √°llapot√°nak null√°z√°sa
        REWARDS['sprint_start'].used = false; 
        
        clearSelection();
        foundWords.clear();
        sprintFoundWords.clear();
        sprintScore = 0;
        
        if (isWarmupRound) {
            WORD_COUNT = WARMUP_WORD_COUNT;
            levelDisplay.textContent = "BEMELEG√çT≈ê K√ñR";
            updateScore(0, true);
        } else {
            WORD_COUNT = LADDER_WORD_COUNTS[gameState.ladderLevel - 1];
            if (isRisking) {
                levelDisplay.textContent = `B√ìNUSZ K√ñR (SZINT ${gameState.ladderLevel})`;
                multiplierDisplay.style.display = 'block';
            } else {
                levelDisplay.textContent = `√âLES K√ñR (SZINT ${gameState.ladderLevel})`;
                multiplierDisplay.style.display = 'none';
                updateScore(0, true);
            }
        }
        
        generateGrid();
        drawGrid();
        populateWordList();
        
        if (!isWarmupRound && gameState.upgrades.starting_hint > 0 && wordsToFind.length > 0) {
            processFoundWord(wordsToFind[0], true);
            applyPermanentHighlight(wordsToFind[0]);
        }
        
        updateRewardsUI();

        newBoardBtn.style.display = 'none';
        timerDisplay.style.display = 'block';
        endRoundChoices.style.display = 'none';
        megoldasBtn.style.display = 'block';
        megoldasBtn.disabled = false;
        sprintContainer.style.display = 'none';
        wordsTitle.style.display = 'block';
        wordListElement.style.display = 'block';
        sprintWordsList.innerHTML = '';
        sprintScoreElement.textContent = '0';
    }
    
    function populateWordList() {
        wordListElement.innerHTML = '';
        const isChampionLevel = !isWarmupRound && gameState.ladderLevel === 5;

        wordsToFind.sort((a,b) => a.localeCompare(b)).forEach((word, index) => {
            const li = document.createElement('li');
            li.textContent = word;
            li.id = 'word-' + word;
            if(isChampionLevel && index > 0) {
                li.classList.add('hidden-word');
            }
            wordListElement.appendChild(li);
        });
    }

    function applyPermanentHighlight(word) {
        const locations = wordLocations.get(word);
        if (locations) {
            locations.forEach(loc => {
                const cellElement = gridContainer.querySelector(`[data-row='${loc.r}'][data-col='${loc.c}']`);
                if (cellElement) {
                    cellElement.classList.add('hint-found');
                }
            });
        }
    }
    
    function processFoundWord(word, noPoints = false) {
        if (!word || foundWords.has(word)) return;
    
        foundWords.add(word);
        const li = document.getElementById('word-' + word);
        if (li) {
            li.classList.add('found');
        }
    
        if (!isWarmupRound && !noPoints) {
            let multiplier = 1 + (gameState.upgrades.point_multiplier * 0.05);
            if(isRisking) multiplier *= 2;
            if(activePowerUp.type === 'double_points') multiplier *= 2;
            updateScore((word.length * 10) * multiplier);
        }
        
        // JAV√çT√ÅS: Itt m√°r csak a gy≈ëzelmi √°llapotot √°ll√≠tjuk be, √©s elind√≠tjuk a sprintet
        if (foundWords.size === WORD_COUNT && isGameActive && !isWarmupRound) {
            roundWon = true;
            enterSprintMode();
        }
    }

    function updateScore(points, absolute = false) {
        if (absolute) {
            currentScore = points;
        } else {
            currentScore += Math.round(points);
        }
        scoreElement.textContent = currentScore;
        updateRewardsUI();
    }

    function updateSodaPenzUI() {
        sodaPenzBalanceElement.textContent = gameState.sodaPenz;
        updatePiacUI();
    }
    
    function handleSelection(event) {
        event.preventDefault();
        const target = event.type.startsWith('touch') ? document.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY) : event.target;
    
        if (target && target.classList.contains('grid-cell') && !target.classList.contains('selected')) {
             if (gridContainer.style.pointerEvents === 'none') return;
            target.classList.add('selected');
            selectedCells.push(target);
            updateCurrentWord();
        }
    }
    
    async function checkSelectedWord() {
        const selectedWord = currentWordPreview.textContent;

        let isValidPath = true;
        if (selectedCells.length > 1) {
            const r1 = parseInt(selectedCells[0].dataset.row);
            const c1 = parseInt(selectedCells[0].dataset.col);
            const r2 = parseInt(selectedCells[1].dataset.row);
            const c2 = parseInt(selectedCells[1].dataset.col);
            const dr = r2 - r1;
            const dc = c2 - c1;

            if (Math.abs(dr) > 1 || Math.abs(dc) > 1 || (dr !== 0 && dc !== 0)) {
                isValidPath = false;
            } else {
                 for (let i = 2; i < selectedCells.length; i++) {
                    const prev_r = parseInt(selectedCells[i-1].dataset.row);
                    const prev_c = parseInt(selectedCells[i-1].dataset.col);
                    const curr_r = parseInt(selectedCells[i].dataset.row);
                    const curr_c = parseInt(selectedCells[i].dataset.col);
                    if (curr_r - prev_r !== dr || curr_c - prev_c !== dc) {
                        isValidPath = false;
                        break;
                    }
                }
            }
        }

        if (!isValidPath) {
            clearSelection();
            return;
        }

        if(selectedWord.length < 2) {
            clearSelection();
            return;
        }
        
        if (isSprintMode) {
            const isValid = await isValidHungarianWord(selectedWord);
            if (isValid && !sprintFoundWords.has(selectedWord) && !wordsToFind.includes(selectedWord)) {
                sprintFoundWords.add(selectedWord);
                const points = Math.pow(selectedWord.length, 2);
                sprintScore += points;
                sprintScoreElement.textContent = sprintScore;
                
                const li = document.createElement('li');
                li.textContent = `${selectedWord} (+${points})`;
                sprintWordsList.prepend(li);
            }
            clearSelection();
            return;
        }

        if (wordsToFind.includes(selectedWord) && !foundWords.has(selectedWord)) {
            const locations = wordLocations.get(selectedWord);
            const selectedLocations = selectedCells.map(cell => ({r: parseInt(cell.dataset.row), c: parseInt(cell.dataset.col)}));

            let pathMatches = locations && locations.length === selectedLocations.length && 
                              locations.every((loc, i) => loc.r === selectedLocations[i].r && loc.c === selectedLocations[i].c);
            let reversePathMatches = locations && locations.length === selectedLocations.length &&
                                     locations.every((loc, i) => loc.r === selectedLocations[locations.length - 1 - i].r && loc.c === selectedLocations[locations.length - 1 - i].c);

            if (pathMatches || reversePathMatches) {
                 const currentSelection = [...selectedCells];
                 const wordToProcess = selectedWord;
                 
                 clearSelection();
                 processFoundWord(wordToProcess);
                 
                 currentSelection.forEach(cell => {
                    cell.classList.add('selected'); // Visszatessz√ºk a narancs kijel√∂l√©st az anim√°ci√≥ idej√©re
                    const r = parseInt(cell.dataset.row);
                    const c = parseInt(cell.dataset.col);
                    const cellData = grid[r][c];
                    if (cellData.hiddenLetter && !collectedSodaLetters.has(cellData.hiddenLetter)) {
                        collectedSodaLetters.add(cellData.hiddenLetter);
                        updateSodaHuntUI();
                        const icon = cell.querySelector('.hidden-bubble-icon');
                        if(icon) icon.style.opacity = '0';
                    }
                 });
                 
                 setTimeout(() => {
                    currentSelection.forEach(cell => {
                        cell.classList.remove('selected');
                    });
                    applyPermanentHighlight(wordToProcess);
                 }, 2000);

            } else {
                 clearSelection();
            }
        } else {
           clearSelection();
        }
    }

    function updateCurrentWord() {
        currentWordPreview.textContent = selectedCells.map(cell => cell.textContent).join('');
    }

    function undoLastSelection() {
        if (selectedCells.length > 0) {
            const lastCell = selectedCells.pop();
            lastCell.classList.remove('selected');
            updateCurrentWord();
        }
    }
    
    function clearSelection() {
        selectedCells.forEach(cell => cell.classList.remove('selected'));
        selectedCells = [];
        updateCurrentWord();
    }
    
    async function isValidHungarianWord(word) {
        // JAV√çT√ÅS: A sprint m√≥d most m√°r 2 bet≈±s szavakat is elfogad
        if (word.length < 2) return false;
        const upperCaseWord = word.toUpperCase();
        if (fullWordSet.has(upperCaseWord)) return true;

        // Az API h√≠v√°s marad m√°sodlagos ellen≈ërz√©snek
        try {
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/hu/${word.toLowerCase()}`);
            return response.ok;
        } catch (error) {
            console.error("Dictionary API error:", error);
            return false;
        }
    }

    function enterSprintMode() {
        isSprintMode = true;
        megoldasBtn.style.display = 'none';
        
        wordsTitle.style.display = 'none';
        wordListElement.style.display = 'none';
        sprintContainer.style.display = 'flex';
        
        levelDisplay.textContent = 'SZ√ìDA SPRINT!';
    }
    
    // JAV√çT√ÅS: Teljesen √°t√≠rt k√∂r v√©gi logika
    function endRound() {
        if (!isGameActive) return;
        isGameActive = false;
        isSprintMode = false;
        
        timerDisplay.style.display = 'none';
        megoldasBtn.disabled = true;

        if(isWarmupRound) {
            newBoardBtn.style.display = 'block';
            newBoardBtn.textContent = 'V√°runk a k√∂vetkez≈ë √©les k√∂rre...';
            return;
        }

        // Ha a j√°t√©kos kock√°ztatott, de nem nyert
        if (isRisking && !roundWon) {
            levelDisplay.textContent = "Kock√°zat Elvesztve!";
            updateScore(0, true);
            riskedScore = 0;
            gameState.ladderLevel = 1; // Vissza az elej√©re
            newBoardBtn.style.display = 'block';
            newBoardBtn.textContent = '√öjrapr√≥b√°lkoz√°s a k√∂vetkez≈ë k√∂rben';
            isRisking = false;
            multiplierDisplay.style.display = 'none';
            saveGameState();
            return;
        }
        
        // Ha a j√°t√©kos gy≈ëz√∂tt (ak√°r sprint ut√°n, ak√°r pont az id≈ë lej√°rtakor)
        if (roundWon) {
             // Bajnoki szint speci√°lis kezel√©se
             if (gameState.ladderLevel === 5) {
                 levelDisplay.textContent = "BAJNOKI C√çM MEGSZEREZVE!";
                 gameState.championUntil = new Date().getTime() + (7 * 24 * 60 * 60 * 1000);
                 championTrophy.style.display = 'inline';
                 cashInPoints(); // Automatikusan bev√°ltja √©s resetel
                 gameState.ladderLevel = 1;
             } else {
                levelDisplay.textContent = `SZINT ${gameState.ladderLevel} TELJES√çTVE!`;
                endRoundChoices.style.display = 'flex'; // FELAJ√ÅNLJA A V√ÅLASZT√ÅST
             }
        } 
        // Ha az id≈ë egyszer≈±en lej√°rt, an√©lk√ºl, hogy gy≈ëz√∂tt volna
        else {
            levelDisplay.textContent = "Id≈ë Lej√°rt!";
            cashInPoints(); // Automatikusan bev√°ltja
            gameState.ladderLevel = 1;
            newBoardBtn.style.display = 'block';
            newBoardBtn.textContent = '√öjrapr√≥b√°lkoz√°s a k√∂vetkez≈ë k√∂rben';
        }
        
        saveGameState();
    }
    
    function cashInPoints() {
        let sodaPenzGained = Math.floor(currentScore / 100);
        sodaPenzGained += sprintScore;
        const sodaMultiplier = 1 + (gameState.upgrades.soda_penz_multiplier * 0.05);
        sodaPenzGained = Math.round(sodaPenzGained * sodaMultiplier);

        gameState.sodaPenz += sodaPenzGained;
        gameState.ladderLevel = 1; // Vissza√°ll az 1. szintre
        isRisking = false;
        
        updateScore(0, true);
        riskedScore = 0;
        updateSodaPenzUI();
        saveGameState();

        endRoundChoices.style.display = 'none';
        newBoardBtn.style.display = 'block';
        newBoardBtn.textContent = 'V√°runk a k√∂vetkez≈ë √©les k√∂rre...';
    }

    function riskIt() {
        isRisking = true;
        riskedScore = currentScore; // A t√©t az eddigi pontsz√°m
        gameState.ladderLevel++; // L√©p√©s a k√∂vetkez≈ë szintre
        
        endRoundChoices.style.display = 'none';
        newBoardBtn.style.display = 'block';
        newBoardBtn.textContent = 'V√°runk a k√∂vetkez≈ë √©les k√∂rre...';
        // A t√©nyleges √∫j k√∂r ind√≠t√°s√°t a f≈ë id≈ëz√≠t≈ë v√©gzi el
    }
    
    function updateTimer() {
        const now = new Date();
        const diff = nextBoardDate.getTime() - now.getTime();
        
        if (diff <= 0) {
            if (isGameActive) endRound();
            
            const totalMsInCycle = CYCLE_MINUTES * 60 * 1000;
            const msSinceEpoch = new Date().getTime();
            const cycleStartEpoch = Math.floor(msSinceEpoch / totalMsInCycle) * totalMsInCycle;
            nextBoardDate = new Date(cycleStartEpoch + totalMsInCycle);

            startNewRound(false);
        }
        
        if (isGameActive) {
            const minutes = Math.floor(diff / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);
            timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            timerDisplay.classList.toggle('warmup-round', isWarmupRound);
        } else {
             const minutes = Math.floor(diff / 60000);
             const seconds = Math.floor((diff % 60000) / 1000);
             newBoardBtn.textContent = `K√∂vetkez≈ë √©les k√∂r: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
             newBoardBtn.style.display = 'block';
             timerDisplay.style.display = 'none';
        }
    }

    function setupInitialTimer() {
        const totalMsInCycle = CYCLE_MINUTES * 60 * 1000;
        const msSinceEpoch = new Date().getTime();
        const cycleStartEpoch = Math.floor(msSinceEpoch / totalMsInCycle) * totalMsInCycle;
        const cycleEndEpoch = cycleStartEpoch + totalMsInCycle;
        
        nextBoardDate = new Date(cycleEndEpoch);
        
        const timeIntoCycle = msSinceEpoch - cycleStartEpoch;

        if (timeIntoCycle < 15000 && timeIntoCycle > 0) {
            startNewRound(false);
        } else {
            startNewRound(true);
        }
        
        setInterval(updateTimer, 1000);
    }

    function updateRewardsUI() {
        rewardsListElement.innerHTML = '';
        for (const [id, reward] of Object.entries(REWARDS)) {
            const item = document.createElement('div');
            item.className = 'reward-item';
            item.dataset.id = id;
            
            let isAffordable = currentScore >= reward.cost && isGameActive && !isWarmupRound;
            if (id === 'sprint_start' && reward.used) isAffordable = false;

            if (isAffordable) item.classList.add('affordable');
            else item.classList.add('disabled');

            item.innerHTML = `
                <div class="reward-name">${reward.name}</div>
                <div class="reward-desc">${reward.desc}</div>
                <div class="reward-cost">${reward.cost.toLocaleString()} pont</div>
            `;
            item.addEventListener('click', () => buyReward(id));
            rewardsListElement.appendChild(item);
        }
    }

    function updatePiacUI() {
        piacListElement.innerHTML = '';
        for (const [id, itemData] of Object.entries(PIAC_ITEMS)) {
            const currentLevel = gameState.upgrades[id] || 0;
            if (currentLevel >= itemData.maxLevel) continue;

            const item = document.createElement('div');
            item.className = 'reward-item piac-item';
            item.dataset.id = id;
            
            const isAffordable = gameState.sodaPenz >= itemData.cost;
            if (isAffordable) item.classList.add('affordable');
            else item.classList.add('disabled');
            
            item.innerHTML = `
                <div class="reward-name">${itemData.name} (${currentLevel}/${itemData.maxLevel})</div>
                <div class="reward-desc">${itemData.desc}</div>
                <div class="piac-cost">${itemData.cost.toLocaleString()} SP</div>
            `;
            item.addEventListener('click', () => buyPiacItem(id));
            piacListElement.appendChild(item);
        }
    }
    
    function buyReward(id) {
        if (!isGameActive || isWarmupRound) return;

        const reward = REWARDS[id];
        let canBuy = currentScore >= reward.cost;
        if(id === 'sprint_start' && reward.used) canBuy = false;

        if (canBuy) {
            updateScore(-reward.cost);
            
            switch(id) {
                case 'hint':
                    const unFoundWords = wordsToFind.filter(w => !foundWords.has(w));
                    if (unFoundWords.length > 0) {
                        const wordToHint = unFoundWords[Math.floor(Math.random() * unFoundWords.length)];
                        processFoundWord(wordToHint, true);
                        applyPermanentHighlight(wordToHint);
                    }
                    break;
                case 'reveal_letter':
                    const unFound = wordsToFind.filter(w => !foundWords.has(w));
                     if (unFound.length > 0) {
                        const wordToReveal = unFound[Math.floor(Math.random() * unFound.length)];
                        const li = document.getElementById('word-' + wordToReveal);
                        if (li && !li.querySelector('.revealed-letter')) {
                             li.innerHTML = `<span class="revealed-letter">${wordToReveal[0]}</span>${' _'.repeat(wordToReveal.length - 1)}`;
                        }
                    }
                    break;
                case 'soda_sense':
                    const cellsToGlow = new Set();
                    wordsToFind.forEach(word => {
                        if (!foundWords.has(word)) {
                            const locations = wordLocations.get(word);
                            if (locations) {
                                locations.forEach(loc => {
                                    const cellElement = gridContainer.querySelector(`[data-row='${loc.r}'][data-col='${loc.c}']`);
                                    if(cellElement) cellsToGlow.add(cellElement);
                                });
                            }
                        }
                    });
                    cellsToGlow.forEach(cell => cell.classList.add('soda-sense-glow'));
                    activatePowerUp('Sz√≥da-√ârz√©k akt√≠v!', 20000);
                    setTimeout(() => {
                        cellsToGlow.forEach(cell => cell.classList.remove('soda-sense-glow'));
                    }, 20000);
                    break;
                case 'sprint_start':
                    if (!REWARDS['sprint_start'].used) {
                        REWARDS['sprint_start'].used = true;
                        enterSprintMode();
                        nextBoardDate = new Date(nextBoardDate.getTime() + 30000);
                        activatePowerUp('Sprint B√≥nusz Id≈ë!', 30000);
                    }
                    break;
            }

            updateRewardsUI();
        }
    }

    function buyPiacItem(id) {
        const item = PIAC_ITEMS[id];
        const currentLevel = gameState.upgrades[id] || 0;

        if (gameState.sodaPenz >= item.cost && currentLevel < item.maxLevel) {
            gameState.sodaPenz -= item.cost;
            gameState.upgrades[id] = currentLevel + 1;

            updateSodaPenzUI();
            updatePiacUI();
            saveGameState();
        }
    }

    function switchShopTab(tab) {
        if (tab === 'piac') {
            tabNyeremeny.classList.remove('active');
            tabPiac.classList.add('active');
            rewardsListElement.style.display = 'none';
            piacListElement.style.display = 'block';
        } else {
            tabPiac.classList.remove('active');
            tabNyeremeny.classList.add('active');
            piacListElement.style.display = 'none';
            rewardsListElement.style.display = 'block';
        }
    }
    
    function updateSodaHuntUI() {
        let allCollected = true;
        Array.from(sodaHuntLetters).forEach(span => {
            const letter = span.dataset.letter;
            if(collectedSodaLetters.has(letter)) {
                span.classList.add('collected');
            } else {
                allCollected = false;
            }
        });

        if (allCollected) {
            sodaHuntClaimBtn.style.display = 'block';
        }
    }
    
    function claimSodaHuntReward() {
        gameState.sodaPenz += 500;
        collectedSodaLetters.clear();
        Array.from(sodaHuntLetters).forEach(span => span.classList.remove('collected'));
        sodaHuntClaimBtn.style.display = 'none';
        updateSodaPenzUI();
        saveGameState();
    }

    function activatePowerUp(displayText, durationMs, type = null) {
        if(activePowerUp.timer) clearTimeout(activePowerUp.timer);

        activePowerupDisplay.textContent = displayText;
        activePowerUp.type = type;

        activePowerUp.timer = setTimeout(() => {
            activePowerupDisplay.textContent = '';
            activePowerUp.type = null;
        }, durationMs);
    }
    
    function setupEventListeners() {
        const startSelection = (e) => {
            if (!isGameActive || gridContainer.style.pointerEvents === 'none') return;
            e.preventDefault();
            clearSelection();
            isSelecting = true;
            handleSelection(e);
        };

        const moveSelection = (e) => {
            if (!isSelecting) return;
            e.preventDefault();
            handleSelection(e);
        };

        const endSelection = (e) => {
            if (!isSelecting) return;
            e.preventDefault();
            isSelecting = false;
            checkSelectedWord();
        };

        gridContainer.addEventListener('mousedown', startSelection);
        gridContainer.addEventListener('mousemove', moveSelection);
        document.addEventListener('mouseup', endSelection);
        document.addEventListener('mouseleave', endSelection);

        gridContainer.addEventListener('touchstart', startSelection, { passive: false });
        gridContainer.addEventListener('touchmove', moveSelection, { passive: false });
        document.addEventListener('touchend', endSelection);
        document.addEventListener('touchcancel', endSelection);


        clearSelectionBtn.addEventListener('click', clearSelection);
        undoSelectionBtn.addEventListener('click', undoLastSelection);

        megoldasBtn.addEventListener('click', () => {
            if (isWarmupRound || !isGameActive) return;

            wordsToFind.forEach(word => {
                if (!foundWords.has(word)) {
                    processFoundWord(word, true);
                    applyPermanentHighlight(word);
                }
            });
            megoldasBtn.disabled = true;
            gridContainer.style.pointerEvents = 'none';
        });

        tabNyeremeny.addEventListener('click', () => switchShopTab('nyeremeny'));
        tabPiac.addEventListener('click', () => switchShopTab('piac'));

        btnCashIn.addEventListener('click', cashInPoints);
        btnRiskIt.addEventListener('click', riskIt);
        sodaHuntClaimBtn.addEventListener('click', claimSodaHuntReward);
    }

    function init() {
        document.getElementById('main-content').style.opacity = '1';
        loadGameState();
        setupEventListeners();
        setupInitialTimer();
        updateRewardsUI();
        updatePiacUI();
        updateSodaHuntUI();
    }

    init();
});
    </script>
</body>
</html>
