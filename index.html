<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Szóda</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@300;400&display=swap');

        :root {
            --dark-blue: #0f172a; --mid-blue: #1e293b; --light-blue-text: #e0f7fa;
            --neon-cyan: #00bfff; --neon-green: #4ade80; --neon-amber: #f59e0b;
            --neon-purple: #c084fc;
        }

        body {
            font-family: 'Roboto', sans-serif; background-color: var(--dark-blue);
            color: var(--light-blue-text); text-align: center; margin: 0; padding: 20px;
            -webkit-tap-highlight-color: transparent;
        }
        
        #main-content { opacity: 0; transition: opacity 1s ease-in; }

        #game-layout {
            display: flex;
            justify-content: center;
            align-items: stretch; 
            gap: 30px;
            max-width: 1400px;
            margin: auto;
        }
        #left-column, #right-column { width: 280px; display: flex; flex-direction: column; flex-shrink: 0; }
        #center-column { display: flex; flex-direction: column; align-items: center; flex-shrink: 0; }
        
        #logo-container { position: relative; margin-bottom: 20px; }
        .logo-text { font-family: 'Orbitron', sans-serif; font-size: 5em; font-weight: bold; color: #ffffff; text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan); }
        
        .static-bubble {
            position: absolute; border-radius: 50%; background: rgba(0, 191, 255, 0.2);
            box-shadow: inset 0 0 10px rgba(255,255,255,0.5); z-index: -1;
            animation: fizz 6s ease-in-out infinite;
        }
        
        .sb1 { width: 50px; height: 50px; top: -10px; left: -30px; animation-delay: 0s; }
        .sb2 { width: 30px; height: 30px; top: 60%; right: -40px; animation-delay: -1.5s; }
        .sb3 { width: 60px; height: 60px; bottom: -20px; right: 50px; animation-delay: -3s; }
        .sb4 { width: 20px; height: 20px; bottom: 0; left: 20px; animation-delay: -4.5s; }

        @keyframes fizz {
            0% { transform: translateY(0) scale(1); opacity: 0.7; }
            25% { transform: translateY(-5px) scale(1.05); opacity: 0.5; }
            50% { transform: translateY(0) scale(0.95); opacity: 0.9; }
            75% { transform: translateY(5px) scale(1); opacity: 0.6; }
            100% { transform: translateY(0) scale(1); opacity: 0.7; }
        }

        .panel {
            padding: 20px; background-color: rgba(15, 23, 42, 0.8);
            border-radius: 8px; border: 1px solid rgba(0, 191, 255, 0.3);
            display: flex; flex-direction: column; position: relative; width: 100%; box-sizing: border-box;
            flex-grow: 1;
        }
        .panel-inner { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        .panel::before, .panel::after, .panel-inner::before, .panel-inner::after {
            content: ''; position: absolute; width: 15px; height: 15px;
            border-color: var(--neon-cyan); border-style: solid; opacity: 0.7;
        }
        .panel::before { top: 8px; left: 8px; border-width: 2px 0 0 2px; }
        .panel::after { top: 8px; right: 8px; border-width: 2px 2px 0 0; }
        .panel-inner::before { bottom: 8px; left: 8px; border-width: 0 0 2px 2px; }
        .panel-inner::after { bottom: 8px; right: 8px; border-width: 0 2px 2px 0; }

        #word-list-container h3, #rewards-container h3 { font-family: 'Orbitron', sans-serif; margin-top: 0; color: var(--neon-cyan); text-shadow: 0 0 5px var(--neon-cyan); }
        #timer-container { min-height: 60px; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; }
        #timer-display { font-family: 'Orbitron', sans-serif; font-size: 1.2em; color: var(--light-blue-text); text-shadow: 0 0 5px var(--neon-cyan); margin-bottom: 5px; }
        #timer-display.warmup-round { color: var(--neon-amber); }
        
        #new-board-btn { display: none; padding: 15px 30px; font-size: 1.2em; font-family: 'Orbitron', sans-serif; cursor: pointer; color: white; background: linear-gradient(45deg, var(--neon-green), #22c55e); border: none; border-radius: 5px; }

        #end-round-choices { display: none; gap: 10px; }
        .choice-btn { flex: 1; padding: 10px; font-family: 'Orbitron', sans-serif; font-size: 0.9em; border-radius: 5px; border: none; cursor: pointer; color: white; }
        #btn-cash-in { background: linear-gradient(45deg, var(--neon-green), #22c55e); }
        #btn-risk-it { background: linear-gradient(45deg, var(--neon-amber), #e18c41); }

        #words {
            list-style: none; padding: 0; margin: 0;
            flex-grow: 1;
            column-count: 2;
            column-gap: 20px;
        }
        #words li { 
            padding: 5px; 
            margin-bottom: 5px; 
            font-size: 1.1em; 
            border-radius: 5px; 
            transition: all 0.3s ease; 
            text-align: left;
            -webkit-column-break-inside: avoid;
            page-break-inside: avoid;
            break-inside: avoid;
        }
        #words li.found { 
            background: rgba(74, 222, 128, 0.2); 
            color: #a7f3d0;
            text-decoration: line-through;
            text-decoration-thickness: 2px;
            font-style: italic;
        }
        #rewards-list, #piac-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #piac-list { display: none; }
        
        .panel-bottom-section { margin-top: auto; padding-top: 15px; }
        #solution-container { margin-bottom: 15px; }
        #megoldas-btn {
            display: none; padding: 10px 20px; font-size: 1.1em;
            font-family: 'Orbitron', sans-serif; cursor: pointer; color: white;
            background: linear-gradient(45deg, var(--neon-amber), #e18c41);
            border: none; border-radius: 5px; width: 100%;
        }
        #megoldas-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        #score-container { text-align: center; flex-shrink: 0; position: relative; }
        #score { font-size: 2.5em; color: var(--neon-amber); font-weight: bold; }

        #multiplier-display { 
            display: none; 
            position: absolute; top: 0; right: 0; 
            background-color: var(--neon-amber); color: var(--dark-blue); 
            font-family: 'Orbitron', sans-serif; font-weight: bold;
            padding: 2px 6px; border-radius: 4px; font-size: 0.8em;
        }
        
        #grid-container {
            display: grid; grid-template-columns: repeat(9, 60px);
            gap: 5px; padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 191, 255, 0.5);
            touch-action: none;
        }
        .grid-cell {
            width: 60px; height: 60px; display: flex; justify-content: center; align-items: center;
            background-color: var(--mid-blue); color: var(--light-blue-text);
            cursor: pointer; font-size: 2.5em; font-weight: bold; text-transform: uppercase;
            user-select: none; border-radius: 5px; transition: all 0.2s ease;
            position: relative;
        }
        .grid-cell.hint-found { background-color: #0c4a6e; color: #7dd3fc; box-shadow: 0 0 15px var(--neon-cyan); cursor: not-allowed; }
        .grid-cell.selected { background-color: var(--neon-amber); color: var(--mid-blue); box-shadow: 0 0 15px var(--neon-amber); transform: scale(1.05); }
        
        .grid-cell.bonus-dp { background-color: #4a330c; color: var(--neon-amber); box-shadow: 0 0 15px var(--neon-amber); }
        .grid-cell.bonus-time { background-color: #0c4a2e; color: var(--neon-green); box-shadow: 0 0 15px var(--neon-green); }

        .hidden-bubble-icon {
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.4) 0%, rgba(0, 191, 255, 0.1) 70%);
            border-radius: 50%;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #current-word-container { display: flex; align-items: center; justify-content: center; margin-top: 15px; height: 50px; gap: 15px;}
        #current-word-preview {
            font-size: 2em; color: var(--neon-amber); letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif; text-transform: uppercase;
            flex-grow: 1; text-align: center;
        }
        #clear-selection-btn {
            display: none; padding: 8px 15px; font-size: 0.9em;
            font-family: 'Orbitron', sans-serif; cursor: pointer; color: var(--dark-blue);
            background: var(--neon-amber); border: none; border-radius: 5px;
        }

        .reward-item {
            background-color: var(--mid-blue); border: 1px solid #334155;
            padding: 15px; margin-bottom: 12px;
            border-radius: 5px; cursor: pointer; transition: all 0.2s; text-align: left;
        }
        .reward-item.disabled { opacity: 0.4; cursor: not-allowed; }
        .reward-item.affordable {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan), 0 0 5px var(--neon-cyan) inset;
        }
        .piac-item.affordable {
            border-color: var(--neon-purple);
            box-shadow: 0 0 15px var(--neon-purple), 0 0 5px var(--neon-purple) inset;
        }
        .reward-name { font-weight: bold; font-size: 1.1em; color: #93c5fd; }
        .reward-desc { font-size: 0.8em; margin: 5px 0; color: #94a3b8; }
        .reward-cost { font-weight: bold; color: var(--neon-amber); text-align: right; }
        .piac-cost { font-weight: bold; color: var(--neon-purple); text-align: right; }

        #copyright { font-size: 0.9em; color: #64748b; margin-top: -10px; margin-bottom: 20px; }

        #rules-container { max-width: 800px; margin: 40px auto 0 auto; text-align: left; }
        #rules-container h2 { font-family: 'Orbitron', sans-serif; color: var(--neon-cyan); text-align: center; }
        #rules-container ul { list-style: none; padding-left: 0; }
        #rules-container li { margin-bottom: 15px; padding-left: 25px; position: relative; }
        #rules-container li::before { content: '>'; position: absolute; left: 0; color: var(--neon-cyan); font-weight: bold; }

        #soda-hunt-container { border-top: 1px solid rgba(0, 191, 255, 0.3); margin-top: 15px; padding-top: 15px; }
        #soda-hunt-letters { display: flex; justify-content: space-around; font-family: 'Orbitron', sans-serif; font-size: 2em; }
        #soda-hunt-letters span { color: #475569; transition: all 0.3s ease-in-out; }
        #soda-hunt-letters span.collected { color: var(--neon-cyan); text-shadow: 0 0 10px var(--neon-cyan); transform: scale(1.2); }
        #soda-hunt-claim-btn { display: none; width: 100%; margin-top: 10px; padding: 10px; font-family: 'Orbitron', sans-serif; font-size: 1.2em; background: linear-gradient(45deg, var(--neon-purple), #9333ea); color: white; border: none; border-radius: 5px; cursor: pointer; }
        #active-powerup-display { font-size: 0.8em; color: var(--neon-green); margin-top: 10px; height: 20px;}
        
        #soda-penz-display { text-align: center; padding: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(0, 191, 255, 0.3); }
        #soda-penz-balance { font-family: 'Orbitron', sans-serif; font-size: 1.8em; color: var(--neon-purple); text-shadow: 0 0 8px var(--neon-purple); }
        .shop-tabs { display: flex; border-bottom: 1px solid rgba(0, 191, 255, 0.3); margin-bottom: 15px; }
        .tab-btn { flex: 1; padding: 10px; background: none; border: none; color: #64748b; font-family: 'Orbitron', sans-serif; cursor: pointer; transition: all 0.2s; }
        .tab-btn.active { color: var(--neon-cyan); background: rgba(0, 191, 255, 0.1); border-bottom: 2px solid var(--neon-cyan); }


        @media (max-width: 900px) {
            body { padding: 10px 5px; }
            #game-layout { flex-direction: column; align-items: center; gap: 25px; }
            #left-column, #right-column, #center-column { width: 100%; max-width: 480px; }
            #center-column { order: 1; }
            #left-column { order: 2; }
            #right-column { order: 3; }
            .logo-text { font-size: 3.5em; }
            #grid-container { width: 95vw; max-width: 480px; height: 95vw; max-height: 480px; grid-template-columns: repeat(9, 1fr); gap: 1.1vw; padding: 1.5vw; }
            .grid-cell { font-size: clamp(14px, 5.5vw, 30px); border-radius: 1vw; }
            #current-word-container { height: 40px; }
            #current-word-preview { font-size: 1.5em; }
            #words li { font-size: 1.1em; padding: 6px 8px;}
            #clear-selection-btn { display: block; }
            #words { column-count: 1; max-height: 25vh; overflow-y: auto; }
            #rewards-list, #piac-list { max-height: 25vh; }
        }
    </style>
</head>
<body>
    <div id="main-content">
        <div id="game-layout">
            <div id="left-column">
                <div id="word-list-container" class="panel">
                    <div class="panel-inner">
                        <div id="timer-container">
                            <div id="timer-display"></div>
                            <button id="new-board-btn">Kezdődjön az éles játék!</button>
                            <div id="end-round-choices">
                                <button id="btn-cash-in" class="choice-btn">Beváltom</button>
                                <button id="btn-risk-it" class="choice-btn">Kockáztatok!</button>
                            </div>
                        </div>
                        <h3>KERESENDŐ SZAVAK</h3>
                        <ul id="words"></ul>
                        <div class="panel-bottom-section">
                            <div id="solution-container">
                                <button id="megoldas-btn">Megoldás Felfedése</button>
                            </div>
                            <div id="score-container">
                                <h3>PONTOK</h3>
                                <div id="score">0</div>
                                <div id="multiplier-display">2x</div>
                            </div>
                            <div id="soda-hunt-container">
                                <h3>SZÓDA-VADÁSZAT</h3>
                                <div id="soda-hunt-letters">
                                    <span data-letter="SZ">SZ</span>
                                    <span data-letter="Ó">Ó</span>
                                    <span data-letter="D">D</span>
                                    <span data-letter="A">A</span>
                                </div>
                                <div id="active-powerup-display"></div>
                                <button id="soda-hunt-claim-btn">BEVÁLTÁS</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="center-column">
                <div id="logo-container">
                    <div class="static-bubble sb1"></div><div class="static-bubble sb2"></div>
                    <div class="static-bubble sb3"></div><div class="static-bubble sb4"></div>
                    <div class="logo-text">Szóda</div>
                </div>
                <div id="copyright">Copyright © by: Robi</div>
                <div id="grid-container"></div>
                <div id="current-word-container">
                    <div id="current-word-preview"></div>
                    <button id="clear-selection-btn">Törlés</button>
                </div>
            </div>
            <div id="right-column">
                <div id="rewards-container" class="panel">
                    <div class="panel-inner">
                        <div id="soda-penz-display">
                            <h3>SZÓDA-PÉNZ</h3>
                            <div id="soda-penz-balance">0</div>
                        </div>
                        <div class="shop-tabs">
                            <button id="tab-nyeremeny" class="tab-btn active">Nyereménybolt</button>
                            <button id="tab-piac" class="tab-btn">Szóda-Piac</button>
                        </div>
                        <div id="rewards-list"></div>
                        <div id="piac-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="rules-container" class="panel">
        <div class="panel-inner">
            <h2>Játékszabályzat</h2>
            <ul>
                <li><strong>A Cél:</strong> Találd meg az összes elrejtett szót a 9x9-es betűrácson, mielőtt lejár az idő!</li>
                <li><strong>10 Perces Körök:</strong> A játék 10 perces körökben zajlik. Ha egy kör közepén csatlakozol, egy tét nélküli <strong>Bemelegítő Kört</strong> játszhatsz a következő teljes kör kezdetéig.</li>
                <li><strong>Szókeresés:</strong> Kösd össze a szomszédos betűket a szavak kirakásához. A keresendő szavak vízszintesen és függőlegesen kanyarognak.</li>
                <li><strong>Kockáztass vagy Gyűjts:</strong> A kör végén dönthetsz: a pontjaidat biztonságban Szóda-Pénzre váltod, vagy kockáztatsz egy 2x szorzóért a következő körben. De vigyázz, ha a bónusz körben nem találsz meg minden szót, a tétként vitt pontjaidat elveszíted!</li>
                <li><strong>Bónusz Mezők:</strong> A sárga (DP) mező megduplázza a szóért kapott pontot, a zöld (+15s) pedig 15 másodpercet ad a hátralévő idődhöz.</li>
                <li><strong>Szóda-Vadàszat:</strong> Gyűjtsd össze a táblán elrejtett SZ-Ó-D-A betűket rejtő buborékokat! Ha mind megvan, beválthatod őket egy 24 órás szuperbónuszra!</li>
                <li><strong>Nyereménybolt & Szóda-Piac:</strong> A pontjaidból körön belüli segítséget vehetsz (Nyereménybolt), a Szóda-Pénzedből pedig maradandó fejlesztéseket és extra erős bónuszokat (Szóda-Piac).</li>
            </ul>
        </div>
    </div>
    
    <script>
        const hungarianWords = [ 'ablak','abszurd','acél','adat','adoma','adottság','áfonya','ág','ágy','agy','ajak','ajándék','ajtó','akarat','akció','akna','alagút','alak','alakulat','alkalom','alkalmazás','alkotás','alkotmány','alku','áll','állam','állat','állomás','álom','ámen','amőba','ampulla','amulett','anekdota','angyal','antenna','anya','anyag','apa','ápoló','apró','áram','arany','aranyos','arc','árok','árpa','áruló','ás','ásatás','átok','autó','avar','azonos','bábu','bajnok','bakter','bal','baleset','balett','balta','bálvány','bánat','banda','bank','bár','barack','bárány','barát','barlang','barna','báró','bástya','bátor','bátrán','bazár','bébi','becsület','béka','béke','bélyeg','bér','berek','beteg','beton','betű','bicikli','bika','bilincs','birtok','bit','bizalom','biztos','blúz','bocs','bocsánat','bodza','bója','bokor','bolt','bolygó','bomba','bor','borbély','borda','bőr','bors','bot','bozót','bögre','bölcs','bölcső','börtön','bőven','búcsú','bura','burgonya','bútor','búvár','bűvész','bűz','cápa','cár','celeb','cél','cella','ceruza','cica','cigány','cikk','cikornya','cím','címer','cipő','cirkusz','citrom','civil','comb','cudar','cukor','cumi','cáfolat','csáb','család','csap','csapat','csapda','csata','csavar','csel','csempe','csend','csengő','cser','csere','cserép','csésze','csiga','csík','csillag','csípő','csirke','csizma','csoda','csók','csomag','csomó','csónak','csont','csoport','cső','csőr','csúcs','csütörtök','dada','dal','dallam','dáma','dara','darázs','dárda','dátum','december','defekt','dekoltázs','dél','delfin','delta','démon','derék','dervis','design','deszka','detektív','deviza','diadém','diák','dicsőség','diktátor','dilemma','dinamit','dinnye','dió','diploma','dísz','disznó','divat','dob','doboz','dohány','doktor','dolog','domb','döntés','dosszié','dózse','dőzs','dráma','drága','droid','duda','duma','düh','dzsem','dzseki','dzsip','dzsungel','eb','ebéd','ecet','éden','edény','edző','ég','egér','egész','egészség','egyetem','egyház','együtt','éj','éjfél','ékszer','elme','élmény','előny','ember','emelet','emlék','emlős','ének','energia','epizód','epres','ér','érc','érdem','erdő','eredet','eredmény','erény','eresz','erő','erőd','erős','érték','érv','esély','eskü','eső','este','ész','észak','eszme','eszperente','eszpresszó','étel','élet','érem','év','ezer','ezredes','fagyi','fagy','faj','fájdalom','fal','falat','falu','far','farag','farok','farkas','farm','farmer','farsang','fátyol','fecske','fegyver','fehér','fej','fejfa','fék','fekete','feladat','felelet','felhő','fél','félelem','fém','fenék','fenyő','férfi','féreg','festék','fésű','fészek','fiaskó','fiatal','fiú','film','filozófia','finom','fiók','fizika','foci','fog','fogoly','fogyás','fóka','fok','fólia','folt','folyamat','folyó','folyosó','fonál','font','forgalom','forint','forma','forrás','forradalom','fotel','fotó','fő','főnök','föld','főút','főváros','főzelék','főzés','friss','front','fullánk','furcsa','fúró','füge','függöny','fű','fürdő','fűrész','fürj','füst','füzet','fűzfa','galamb','gallér','garázs','gazda','gáz','gém','gén','gepárd','gép','gésa','gesztus','gida','giliszta','gimnázium','gipsz','gitár','gladiátor','glória','góbé','gól','golyó','gomb','gomba','gond','gondola','gong','gömb','göndör','göngy','görcs','görény','görög','gőz','gránát','gránit','gróf','gúla','gumi','gúny','gyalog','gyám','gyár','gyász','gyémánt','gyep','gyerek','gyertek','gyertya','gyík','gyilkos','gyógyír','gyökér','gyöngy','gyors','győzelem','gyufa','gyűrű','gyümölcs','ha','hab','had','hagyma','haj','hajnal','hajó','hal','halál','háló','halszálka','hamis','hamu','hang','hangár','hangszer','hangya','harag','harang','harc','harisnya','hárfa','hasonló','has','hat','hatalom','határ','hát','hattyú','havas','ház','hegedű','hegy','héj','hely','helyes','henger','herceg','hering','hét','hétfő','hétvége','hiány','hiba','híd','hideg','himnusz','hinta','hír','hitel','hit','hivatás','hó','hód','hold','holló','homár','homok','honlap','hónap','hordó','horgony','horgász','horoszkóp','hossz','hosszú','hotel','hóvirág','hulla','humor','hurka','hús','húsvét','huzat','hű','hűség','idomár','idő','iker','ikon','illat','illúzió','impala','impulzus','index','indigó','indíték','infó','inger','ing','iroda','irónia','iskola','isten','iszap','ital','ítélet','íz','izom','izzó','jacht','jaguár','jak','január','járda','jáspis','játék','javas','jávorszarvas','jég','jel','jelenség','jellem','jelmez','jelölt','jelvény','jenki','jet','jód','jóga','joghurt','jog','joker','jós','jóság','jövő','július','június','juta','jutalom','kabal','kabát','kabin','kacaj','kacsa','kád','kakas','kakaó','kaktusz','kalap','kalauz','kalóz','kályha','kamion','kámpa','kanál','kancellár','kandúr','kánikula','kanna','káosz','kapa','kaparó','kapcsoló','kapitány','kápolna','káposzta','kapu','kar','karabiner','karakter','karám','karát','karaván','kard','karnevál', 'kártya','kastély','katalógus','katona','kaució','kávé','kazán','kecske','kedd','kedves','kefe','kék','kém','kép','kérdés','kerék','kereszt','keret','kert','kés','keserű','kész','kettő','kever','kéz','kincs','király','kis','kocka','kocsi','kód','köd','kő','kölcsön','költő','kölyök','kömény','könny','könyv','könnyű','kör','kormány','korona','korsó','korzó','kórház','kosár','kosz','kota','kovács','kotor','köz','közeg','közép','közös','kréta','krimi','kripta','kristály','kritika','krokodil','krumpli','kút','kutya','kuvasz','küld','külső','kürt','kvíz','láb','labor','lábszár','láda','lakás','lakat','lakodalmas','láng','lanka','lant','lap','lapát','lassan','lát','látvány','láva','láz','lecke','legenda','légió','légszomj','légy','lehel','lélek','lemez','lencse','lepke','lét','létra','levél','leves','lexikon','liba','lift','liga','likőr','lila','limbó','limit','limonádé','link','líra','lista','ló','lobog','logika','logó','lokál','lomb','lop','lottó','lovag','lóerő','lő','lök','löncs','lucfenyő','lúd','luk','lyuk','macska','madár','mag','mágia','mágnes','magyar','máj','majom','makk','makréla','málna','malom','mályva','mandula','mankó','marad','maraton','marcipán','márga','marha','márka','márvány','más','masina','masni','maszk','matematika','matrica','matróz','medál','medence','meder','medve','méh','mély','menedzser','menny','menü','mér','merénylet','mese','messze','mester','metál','metró','méz','mező','miazma','mikrofon','mikulás','milliárd','milliomos','miniszter','minta','mínusz','mirigy','mise','mitológia','mítosz','mizéria','moha','móka','mókus','molekula','móló','monitor','monokli','monoton','motor','mozi','muzsika','mű','műfaj','műhely','műsor','művész','művelet','nád','nadrág','nagy','naiv','nap','napló','narancs','nárcisz','nász','nátha','négy','négyzet','nép','név','néző','nindzsa','nő','nóta','nővér','nugát','nulla','nyáj','nyak','nyál','nyár','nyárs','nyelv','nyer','nyereg','nyers','nyest','nyíl','nyolc','nyom','nyugalom','nyugat','nyúl','nyúlékony','nyüszít','oázis','obeliszk','objektív','oboa','ócéán','óda','odú','ok','okker','oklevél','okos','október','oktogon','olaj','olasz','oldal','olló','ólom','oltár','olvas','olívabogyó','olyan','omlett','opera','opció','optika','óra','orbáncfű','orchidea','ordináta','orgona','orkán','orom','orosz','orrszarvú','orvos','ostor','ostya','oszlop','oszt','osztály','otthon','öv','özön','őz','pad','padlás','padlizsán','pajkos','pajzs','pákó','pálca','pálma','pálya','páncél','pandúr','panel','pánik','panna','panoráma','pap','papagáj','papír','paprika','papucs','paradicsom','parafa','parancs','parázs','park','párna','pár','párt','part','pasi','passz','paszta','pata','patak','pátens','patika','patkány','páva','pazarlás','peca','pecsét','pedál','pék','pelikán','pemzli','péntek','pénz','pepita','perec','per','peron','persze','pestis','petárda','petrezselyem','pezsgő','pia','piac','piccolo','pihen','pikkely','piktogram','pillanat','pille','pillér','pilóta','pince','pingvin','pinty','pipa','piros','pisztoly','pite','pizsama','placc','plafon','plakát','plankton','pláza','pletyka','plüss','pó','pogácsa','pohár','póker','pók','pokol','polc','polip','politika','pollen','póló','póni','pont','ponty','por','porcelán','porc','poros','porta','portré','posta','poszáta','potya','póz','póker','pörkölt','pötty','prizma','próba','probléma','professzor','program','projekt','próféta','proletár','prospektus','protein','prototípus','púder','puding','pulyka','pumpa','pult','púp','puska','puszi','püspök','rab','rács','radar','radír','rag','ragu','ragyog','raj','rajz','rák','rakéta','ral','randi','rang','rántás','rádió','reakció','reál','recept','reccs','reggae','reggeli','rejtély','reklám','remek','remény','rend','rendszer','repce','repeta','répa','repesz','reptér','rés','rész','rét','retesz','retró','reuma','revolver','rezgés','réz','riadó','ribizli','rigó','rikkancs','ring','riport','ritmus','rituálé','rizs','robot','robban','roham','rokkant','rokon','róka','rom','románc','rossz','rosta','rost','rovar','rozmár','rozs','rögbi','röplabda','rövid','rőzse','rúbel','rubin','rúd','ruha','rúna','rúzs','sajt','sakk','sakál','sál','salak','saláta','sámán','sampion','sánc','sár','sárga','sárkány','sarok','sas','sátor','sav','savanyú','seb','sebész','séf','segéd','segély','sejt','selyem','semmi','serleg','serpenyő','sérv','séta','siga','siker','sikk','sima','sí','sín','síp','sír','sir','sirály','síugrás','sivatag','skatulya','smink','smaragd','sodrás','sógor','só','sok','sör','sors','sóska','sóvárgás','sprint','srác','start','statiszta','stég','stílus','stop','stoppol','strandon','strázsa','stressz','strófa','stúdió','sugallat','sugár','sugárút','súly','sündisznó','sushi','suttogás','süket','sül','sült','sűrű','súrlódás','suttyó','svéd','svindli','szabad','szabály','szabó','száj','szakács','szakáll','szakasz','szaki','szál','szállás','szalma','szalon','szaloncukor','szalonna','szamár','szamóca','szám','szán','szándék','szappan','szar','szarvas','szász','szatyor','száz','század','százalék','szecessió','szeg','szegély','szegény','szegfű','szék','szél','szellem','szelvény','szem','személy','szemét','szemle','szempilla','szemüveg','szén','széna','szendvics','szent','szeptember','szer','szerda','szerelem','szerencse','szeretet','szerkezet','szerszám','szerv','szerver','szerviz','szesz','sziget','szignál','szíj','szikla','szilva','szín','szimfónia','szindróma','színész','színpad','színtér','szirén','szirt','szita','szív','szivar','szivattyú','szleng','szlogen','szó','szoba','szobor','szóda','szófa','szokás','szoknya','szolga','szolárium','szoli','szomszéd','szomorú','szósta','szótag','szótár','szöcske','szög','szőke','szőlő','szőnyeg','szörf','szörny','szövet','szövetség','sztrájk','sztráda','szűcs','szűk','szünet','szűrő','szűz','talaj','találka','talány','taliga','talizmán','talp','tál','tálca','tám','tan','tanács','tanár','tánc','tanfolyam','tanú','tanuló','tanya','tányér','tapasz','taps','tár','tárca','tárgy','tarhonya','tarisznya','tarot','társ','táska','tavasz','taxi','tea','teátrum','technika','teher','tehén','tej','tél','telefon','telek','téma','temető','templom','tempó','tenger','tenisz','tény','tér','terasz','terem','terep','terhes','terv','test','testvér','tető','tészta','tét','tétel','tetoválás','tett','tettes','tévé','tigris','tikk','tilalom','tinta','típus','titán','titok','tíz','tó','tojás','tok','tokaji','toll','tolvaj','tomp','tórusz','torta','torzó','több','tök','tölgy','tömeg','tömény','tömlöc','tömlő','törekvés','törlés','törpe','történet','törvény','törzs','tő','tőke','tőr','tőzsde','traffipax','tragédia','traktor','transz','trapéz','trapper','tréfa','tréning','trón','trófea','trükk','túlsúly','túra','turbán','turi','turista','turné','túsz','tüdő','tükör','túl','túlélő','tücsök','tüntetés','tű','tűz','tűzfal','tűzhely','tűzoltó','uborka','udvar','ugrás','új','újdonság','ujj','újság','ukáz','ultra','univerzum','unoka','urán','úr','uszály','uszoda','út','utas','utca','útitárs','utópia','utószó','ü ü ünnep','üdv','ügynök','üres','űr','üveg','üzenet','vad','vád','vadász','vadon','vagon','vagy','vagyon','vágy','vaj','vakar','vakcina','váll','vállalat','vallás','váltó','vámpír','vám','vár','varangy','váratlan','varázs','város','vas','vásár','vászon','váz','vécé','véd','vég','véletlen','vélemény','vendég','vén','vény','verda','veréb','vers','verseny','verzió','vese','vész','veszély','vetélkedő','vezér','vezető','viasz','vibrálás','vicc','videó','vidra','vigasz','világ','villa','villám','villany','virág','virtus','vírus','viszály','viszki','vitamin','vitorla','vissza','visszhang','vitatkozik','víz','vízesés','víziló','vízöntő','viza','vízum','voks','vonal','vontató','vödör','vőlegény','völgy','vörös','wc','web','whisky','xilofon','yacht','zacc','zaj','zálog','zamat','zár','zarándok','zárójel','zászló','zavar','zebu','zeller','zene','zeng','zéró','zivatar','zodiákus','zombi','zongora','zóna','zord','zörej','zuhan','zuhanás','zúzmara','zsák','zsálya','zsarnok','zselé','zsemle','zseni','zseton','zsinagóga','zsinat','zsinór','zsiráf','zsírkréta','zsoké','zsoldos','zsoltár','zsonglőr','zsuga','zsugori','zsűri','zsúr'
        ];
        
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const GRID_SIZE = 9, WORD_COUNT = 20, CYCLE_DURATION_MS = 10 * 60 * 1000;
        let wordsToFind = [], wordPositions = new Map(), grid = [], selectedCells = [];
        let foundWords = new Set();
        let isSelectingForDesktop = false;
        let score = 0;
        let riskedScore = 0;
        let isRisking = false;
        let isFreeRound = false;
        let isGameActive = true;
        let gameTimer, nextBoardDate;
        
        let collectedSodaLetters = new Set();
        let activePowerUp = { type: null, expires: 0, desc: '' };
        const SODA_LETTERS = ['SZ', 'Ó', 'D', 'A'];
        
        let gameState = { sodaPenz: 0, upgrades: { point_multiplier: 0, discount: 0 }, elixirs: { double_points: 0, magnet: 0 } };

        const mainContent = document.getElementById('main-content');
        const gridContainer = document.getElementById('grid-container');
        const wordListElement = document.getElementById('words');
        const scoreElement = document.getElementById('score');
        const multiplierDisplay = document.getElementById('multiplier-display');
        const rewardsListElement = document.getElementById('rewards-list');
        const piacListElement = document.getElementById('piac-list');
        const newBoardBtn = document.getElementById('new-board-btn');
        const timerDisplay = document.getElementById('timer-display');
        const currentWordPreview = document.getElementById('current-word-preview');
        const megoldasBtn = document.getElementById('megoldas-btn');
        const clearSelectionBtn = document.getElementById('clear-selection-btn');
        const sodaHuntLettersContainer = document.getElementById('soda-hunt-letters');
        const sodaHuntClaimBtn = document.getElementById('soda-hunt-claim-btn');
        const activePowerupDisplay = document.getElementById('active-powerup-display');
        const sodaPenzBalance = document.getElementById('soda-penz-balance');
        const tabNyeremeny = document.getElementById('tab-nyeremeny');
        const tabPiac = document.getElementById('tab-piac');
        const endRoundChoices = document.getElementById('end-round-choices');
        const btnCashIn = document.getElementById('btn-cash-in');
        const btnRiskIt = document.getElementById('btn-risk-it');

        document.addEventListener('DOMContentLoaded', () => {
            mainContent.style.opacity = '1';
            loadGameState();
            startNewRound(0, false);
        });
        
        newBoardBtn.addEventListener('click', () => startNewRound(0, false));
        btnCashIn.addEventListener('click', () => {
            gameState.sodaPenz += Math.floor((score + riskedScore) / 10);
            saveGameState();
            updateSodaPenzDisplay();
            startNewRound(0, false);
        });
        btnRiskIt.addEventListener('click', () => startNewRound(score + riskedScore, true));
        
        megoldasBtn.addEventListener('click', showSolutions);
        clearSelectionBtn.addEventListener('click', clearSelection);
        sodaHuntClaimBtn.addEventListener('click', claimSodaReward);
        tabNyeremeny.addEventListener('click', () => switchTab('nyeremeny'));
        tabPiac.addEventListener('click', () => switchTab('piac'));
        
        function switchTab(tabName) {
            if(tabName === 'nyeremeny') {
                tabNyeremeny.classList.add('active');
                tabPiac.classList.remove('active');
                rewardsListElement.style.display = 'block';
                piacListElement.style.display = 'none';
            } else {
                tabNyeremeny.classList.remove('active');
                tabPiac.classList.add('active');
                rewardsListElement.style.display = 'none';
                piacListElement.style.display = 'block';
            }
        }

        function handleCellTap(cell) {
            if (cell.classList.contains('hint-found') || selectedCells.includes(cell)) return;
            selectCell(cell);
            checkSelectedWord(true);
        }

        function selectionStart(cell) {
            if (!cell || cell.classList.contains('hint-found')) return;
            isSelectingForDesktop = true;
            clearSelection();
            selectCell(cell);
        }

        function selectionMove(cell) {
            if (!isSelectingForDesktop || !cell) return;
            
            if (selectedCells.length > 1 && cell === selectedCells[selectedCells.length - 2]) {
                const lastCell = selectedCells.pop();
                lastCell.classList.remove('selected');
                updateWordPreview();
                return;
            }

            if (cell.classList.contains('selected') || cell.classList.contains('hint-found')) return;
            
            const lastCell = selectedCells[selectedCells.length - 1];
            if (!lastCell) { selectCell(cell); return; }
            
            const r1 = parseInt(lastCell.dataset.row), c1 = parseInt(lastCell.dataset.col);
            const r2 = parseInt(cell.dataset.row), c2 = parseInt(cell.dataset.col);
            
            const dr = r2 - r1;
            const dc = c2 - c1;
            const steps = Math.max(Math.abs(dr), Math.abs(dc));

            if (steps > 1) { 
                for (let i = 1; i <= steps; i++) {
                    const inter_r = r1 + Math.round(i * dr / steps);
                    const inter_c = c1 + Math.round(i * dc / steps);
                    const interCellNode = gridContainer.children[inter_r * GRID_SIZE + inter_c];
                    if (interCellNode && !selectedCells.includes(interCellNode) && !interCellNode.classList.contains('hint-found')) {
                       selectCell(interCellNode);
                    }
                }
            } else if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) {
                 selectCell(cell);
            }
        }

        function selectionEnd() {
            if (!isSelectingForDesktop) return;
            isSelectingForDesktop = false;
            if (selectedCells.length > 0) {
                checkSelectedWord(false);
            }
        }
        
        function selectCell(cell) {
            selectedCells.push(cell);
            cell.classList.add('selected');
            updateWordPreview();
        }

        function clearSelection() {
            selectedCells.forEach(c => c.classList.remove('selected'));
            selectedCells = [];
            updateWordPreview();
        }

        function updateWordPreview() {
            currentWordPreview.textContent = selectedCells.map(c => c.textContent).join('');
        }

        function checkSelectedWord(isTap) {
            const selectedWord = currentWordPreview.textContent;
            if (wordsToFind.includes(selectedWord) && !foundWords.has(selectedWord)) {
                foundWords.add(selectedWord);
                document.getElementById('word-' + selectedWord).classList.add('found');
                
                if(isWarmupRound) {
                    setTimeout(clearSelection, 100);
                    if (!isTap) clearSelection();
                    return; // Bemelegítő körben nincs pont, se bónusz
                }

                let multiplier = 1 + (gameState.upgrades.point_multiplier * 0.05);
                if(isRisking) multiplier *= 2;
                
                selectedCells.forEach(cell => {
                    const r = parseInt(cell.dataset.row);
                    const c = parseInt(cell.dataset.col);
                    const cellData = grid[r][c];

                    if(cellData.hiddenLetter) {
                        collectedSodaLetters.add(cellData.hiddenLetter);
                        cellData.hiddenLetter = null;
                        const icon = cell.querySelector('.hidden-bubble-icon');
                        if(icon) icon.style.opacity = '0';
                        updateSodaHuntUI();
                        saveGameState();
                    }

                    if (isGameActive) {
                        const bonusType = cellData.bonus;
                        if(bonusType) {
                            if(bonusType === 'dp') multiplier *= 2;
                            else if (bonusType === 'time') nextBoardDate = new Date(nextBoardDate.getTime() + 15000);
                            cellData.bonus = null;
                            cell.classList.remove('bonus-dp', 'bonus-time');
                        }
                    }
                });

                if (isGameActive) {
                    if(activePowerUp.type === 'double_points') multiplier *= 2;
                    updateScore((selectedWord.length * 10) * multiplier);
                }

                setTimeout(clearSelection, 100);
            }
            if (!isTap) {
                clearSelection();
            }
        }
        
        function showSolutions() {
            megoldasBtn.disabled = true;
            megoldasBtn.style.display = 'none';
            if(isGameActive) {
                isGameActive = false;
                renderRewards(); 
            }
            wordsToFind.forEach(word => {
                if (!foundWords.has(word)) {
                    const positions = wordPositions.get(word);
                    if (positions) {
                        positions.forEach(pos => {
                            const cell = gridContainer.children[pos.r * GRID_SIZE + pos.c];
                            cell.style.transition = 'background-color 0.5s, box-shadow 0.5s';
                            cell.style.backgroundColor = 'var(--neon-purple)';
                            cell.style.boxShadow = '0 0 15px var(--neon-purple)';
                        });
                    }
                }
            });
        }
        
        function startNewRound(carryOverScore = 0, isRiskingRound = false) {
            isGameActive = true;
            riskedScore = carryOverScore;
            isRisking = isRiskingRound;
            
            const currentSeedStart = Math.floor(Date.now() / CYCLE_DURATION_MS) * CYCLE_DURATION_MS;
            nextBoardDate = new Date(currentSeedStart + CYCLE_DURATION_MS);
            const remainingMilliseconds = nextBoardDate - Date.now();
            
            // A kör elején eldől, hogy szabad kör-e
            isFreeRound = remainingMilliseconds < (9 * 60 * 1000);
            if (isRisking) isFreeRound = false;

            megoldasBtn.style.display = 'none';
            timerDisplay.style.display = 'block';
            newBoardBtn.style.display = 'none';
            endRoundChoices.style.display = 'none';
            multiplierDisplay.style.display = isRisking ? 'block' : 'none';
            
            const timeSeed = Math.floor(Date.now() / CYCLE_DURATION_MS);
            setupNewGame(timeSeed);
            scheduleNextBoard();
        }
        
        function createSeededRandom(seed) { let s = seed; return () => { s = (s * 9301 + 49297) % 233280; return s / 233280; }; }
        function seededShuffle(array, randomFunc) { let i = array.length; while (i) { let j = Math.floor(randomFunc() * i--);[array[i], array[j]] = [array[j], array[i]]; } return array; }
        
        function setupNewGame(seed) {
            megoldasBtn.disabled = false;
            wordsToFind = []; wordPositions.clear(); grid = []; selectedCells = []; foundWords.clear(); score = 0;
            gridContainer.innerHTML = ''; wordListElement.innerHTML = '';
            
            const seededRandom = createSeededRandom(seed);
            
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null).map(() => ({ char: '', bonus: null, hiddenLetter: null })));
            
            let wordSelection = seededShuffle([...hungarianWords], seededRandom);
            
            let placedWordsCount = 0;
            while (placedWordsCount < WORD_COUNT && wordSelection.length > 0) {
                let word = wordSelection.pop().toUpperCase();
                if (word.length > GRID_SIZE || word.length < 3) continue;
                let placement = findPlacementForWord(word, grid, seededRandom);
                if (placement) { 
                    wordsToFind.push(word); 
                    wordPositions.set(word, placement.cells); 
                    placement.cells.forEach((cell, i) => { grid[cell.r][cell.c].char = word[i]; }); 
                    placedWordsCount++; 
                }
            }
            
            fillGridWithRandomLetters(seededRandom);
            placeBonusFields(seededRandom);
            placeSodaLetters(seededRandom);
            renderGrid(); renderWordList(); updateScore(0);
        }
        
        function placeBonusFields(randomFunc) {
            const emptyCells = getEmptyCells();
            seededShuffle(emptyCells, randomFunc);
            
            let bonusCount = 2;
            if (activePowerUp.type === 'bonus_rain') bonusCount = 5;

            for(let i=0; i<bonusCount; i++) if(emptyCells.length > 0) { const pos = emptyCells.pop(); if(pos) grid[pos.r][pos.c].bonus = 'dp'; }
            if(emptyCells.length > 0) { const pos = emptyCells.pop(); if(pos) grid[pos.r][pos.c].bonus = 'time'; }
            if (activePowerUp.type === 'bonus_rain' && emptyCells.length > 0) { const pos = emptyCells.pop(); if(pos) grid[pos.r][pos.c].bonus = 'time'; }
            if (activePowerUp.type === 'bonus_rain' && emptyCells.length > 0) { const pos = emptyCells.pop(); if(pos) grid[pos.r][pos.c].bonus = 'time'; }
        }
        
        function placeSodaLetters(randomFunc) {
            const emptyCells = getEmptyCells();
            seededShuffle(emptyCells, randomFunc);

            const lettersToPlace = [...SODA_LETTERS, SODA_LETTERS[Math.floor(randomFunc() * SODA_LETTERS.length)]];
            for(const letter of lettersToPlace) {
                if(emptyCells.length > 0) {
                    const pos = emptyCells.pop();
                    if(pos) grid[pos.r][pos.c].hiddenLetter = letter;
                }
            }
        }
        
        function getEmptyCells() {
            const emptyCells = [];
            const wordCoords = new Set();
            wordPositions.forEach(positions => { positions.forEach(pos => wordCoords.add(`${pos.r}-${pos.c}`)); });

            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    if(!wordCoords.has(`${r}-${c}`)) {
                        emptyCells.push({r, c});
                    }
                }
            }
            return emptyCells;
        }

        function findPlacementForWord(word, currentGrid, randomFunc) {
            let attempts = 0;
            while (attempts < 100) {
                let path = [{ r: Math.floor(randomFunc() * GRID_SIZE), c: Math.floor(randomFunc() * GRID_SIZE) }];
                for (let i = 1; i < word.length; i++) {
                    let lastPos = path[i - 1]; 
                    let neighbors = getNeighbors(lastPos.r, lastPos.c, path);
                    seededShuffle(neighbors, randomFunc);
                    if (neighbors.length === 0) break;
                    path.push(neighbors[0]);
                }
                if (path.length === word.length) {
                    let canPlace = true;
                    for (let i = 0; i < word.length; i++) { if (currentGrid[path[i].r][path[i].c].char !== '' && currentGrid[path[i].r][path[i].c].char !== word[i]) { canPlace = false; break; } }
                    if (canPlace) return { cells: path };
                }
                attempts++;
            }
            return null;
        }

        function getNeighbors(r, c, exclude) {
            const neighbors = [];
            const moves = [ { dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 } ];

            for (const move of moves) {
                const nr = r + move.dr;
                const nc = c + move.dc;
                if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE && !exclude.some(p => p.r === nr && p.c === nc)) {
                    neighbors.push({ r: nr, c: nc });
                }
            }
            return neighbors;
        }
        
        function fillGridWithRandomLetters(randomFunc) { 
            const alphabet = 'AÁBCDEÉFGHIÍJKLMNOÓÖŐPQRSTUÚÜŰVWXYZ'; 
            for (let i = 0; i < GRID_SIZE; i++) 
                for (let j = 0; j < GRID_SIZE; j++) 
                    if (grid[i][j].char === '') grid[i][j].char = alphabet[Math.floor(randomFunc() * alphabet.length)]; 
        }
        
        function renderGrid() {
            gridContainer.innerHTML = '';
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const cellData = grid[i][j];
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = cellData.char;
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    if(cellData.bonus === 'dp') cell.classList.add('bonus-dp');
                    if(cellData.bonus === 'time') cell.classList.add('bonus-time');
                    if(cellData.hiddenLetter) {
                        const icon = document.createElement('div');
                        icon.className = 'hidden-bubble-icon';
                        cell.appendChild(icon);
                    }

                    cell.style.backgroundColor = '';
                    cell.style.boxShadow = '';
                    cell.style.transition = '';

                    if (isMobile) {
                        cell.addEventListener('touchstart', (e) => { e.preventDefault(); selectionStart(cell); }, { passive: false });
                        cell.addEventListener('touchmove', (e) => { 
                            e.preventDefault();
                            const touch = e.touches[0];
                            const targetCell = document.elementFromPoint(touch.clientX, touch.clientY);
                            if(targetCell && targetCell.classList.contains('grid-cell')) {
                                selectionMove(targetCell);
                            }
                        }, { passive: false });
                        cell.addEventListener('touchend', (e) => { e.preventDefault(); selectionEnd(); });
                    } else {
                        cell.addEventListener('mousedown', () => selectionStart(cell));
                        cell.addEventListener('mouseover', () => selectionMove(cell));
                    }
                    gridContainer.appendChild(cell);
                }
            }
            if (!isMobile) {
                document.addEventListener('mouseup', selectionEnd);
            }
        }

        function renderWordList() { wordListElement.innerHTML = ''; const words = [...wordsToFind].sort((a,b) => a.localeCompare(b)); words.forEach(word => { const li = document.createElement('li'); li.textContent = word; li.id = 'word-' + word; if (foundWords.has(word)) li.classList.add('found'); wordListElement.appendChild(li); }); }

        const rewards = [ { id: 'vowel_hint', name: 'Magánhangzó Tipp', desc: 'Megjelöli egy szó magánhangzóit.', cost: 1000, action: vowelHint }, { id: 'point_bonus', name: 'Pont Bónusz', desc: '+200 pont.', cost: 1500, action: () => updateScore(200) }, { id: 'reveal_letter', name: 'Betű Felfedése', desc: 'Felvillant egy betűt egy szóból.', cost: 2000, action: revealLetter }, { id: 'first_letter', name: 'Első Betű', desc: 'Véglegesen megjelöli egy szó első betűjét.', cost: 4000, action: revealFirstLetter }, { id: 'glimpse_word', name: 'Szópillantás', desc: 'Felvillantja egy szó útvonalát.', cost: 7500, action: glimpseWord }, { id: 'free_pass', name: 'Ingyen Passz', desc: 'Megtalálja a legrövidebb hiányzó szót.', cost: 12000, action: findShortestWord }];
        const piacItems = [
            { id: 'point_multiplier', name: 'Szénsav-Infúzió', desc: 'Véglegesen +5% pontot ad minden szóért.', baseCost: 2500, action: (item) => { gameState.upgrades.point_multiplier++; } },
            { id: 'discount', name: 'Törzsvásárlói Kártya', desc: 'Véglegesen -10% kedvezmény a Nyereményboltban.', baseCost: 4000, action: (item) => { gameState.upgrades.discount++; } },
            { id: 'elixir_double_points', name: 'Arany-Szóda', desc: 'A következő körben minden pont duplán számít.', cost: 5000, action: (item) => { gameState.elixirs.double_points++; } },
            { id: 'elixir_magnet', name: 'Mágneses Buborék', desc: 'A következő körben garantáltan megtalálod a hiányzó SZÓDA betűket.', cost: 7500, action: (item) => { gameState.elixirs.magnet++; } }
        ];

        function updateScore(points) { score = Math.max(0, score + points); scoreElement.textContent = Math.floor(score + riskedScore); renderRewards(); renderPiac(); }
        
        function renderRewards() { 
            rewardsListElement.innerHTML = ''; 
            rewards.forEach(r => { 
                let currentCost = Math.floor(r.cost * (1 - (gameState.upgrades.discount * 0.1)));
                const isAffordable = score >= currentCost;
                const el = document.createElement('div'); 
                el.className = 'reward-item ' + (isAffordable && isGameActive && !isWarmupRound ? 'affordable' : 'disabled'); 
                el.innerHTML = `<div class="reward-name">${r.name}</div><div class="reward-desc">${r.desc}</div><div class="reward-cost">${currentCost} Pont</div>`; 
                if (isAffordable && isGameActive && !isWarmupRound) el.onclick = () => { if (score >= currentCost) { updateScore(-currentCost); r.action(); } }; 
                rewardsListElement.appendChild(el); 
            }); 
        }

        function renderPiac() {
            piacListElement.innerHTML = '';
            piacItems.forEach(item => {
                let currentCost = item.cost;
                if(item.baseCost) {
                    currentCost = Math.floor(item.baseCost * Math.pow(1.5, gameState.upgrades[item.id] || 0));
                }
                const isAffordable = gameState.sodaPenz >= currentCost;
                const el = document.createElement('div');
                el.className = 'reward-item piac-item ' + (isAffordable ? 'affordable' : 'disabled');
                el.innerHTML = `<div class="reward-name">${item.name} ${gameState.upgrades[item.id] ? `(Szint ${gameState.upgrades[item.id] + 1})` : ''}</div><div class="reward-desc">${item.desc}</div><div class="piac-cost">${currentCost} SZP</div>`;
                if(isAffordable) el.onclick = () => buyPiacItem(item, currentCost);
                piacListElement.appendChild(el);
            });
        }

        function buyPiacItem(item, cost) {
            if (gameState.sodaPenz >= cost) {
                gameState.sodaPenz -= cost;
                item.action(item);
                saveGameState();
                updateSodaPenzDisplay();
                renderPiac();
            }
        }
        
        function getUnfoundWord(shortest = false) { let unfound = wordsToFind.filter(w => !foundWords.has(w)); if (unfound.length === 0) return null; if (shortest) unfound.sort((a,b) => a.length - b.length); return unfound[0]; }
        function vowelHint() { const word = getUnfoundWord(); if (!word) return; const vowels = "AÁEÉIÍOÓÖŐUÚÜŰ"; document.getElementById('word-' + word).innerHTML = word.split('').map(l => vowels.includes(l) ? `<span style="color: var(--neon-amber);">${l}</span>` : l).join(''); }
        function revealLetter() { const word = getUnfoundWord(); if (!word) return; const pos = wordPositions.get(word); const cellInfo = pos[Math.floor(Math.random() * pos.length)]; const cell = gridContainer.children[cellInfo.r * GRID_SIZE + cellInfo.c]; cell.classList.add('solution-path'); setTimeout(() => cell.classList.remove('solution-path'), 1000); }
        function revealFirstLetter() { const word = getUnfoundWord(); if (!word) return; const cellInfo = wordPositions.get(word)[0]; gridContainer.children[cellInfo.r * GRID_SIZE + cellInfo.c].classList.add('hint-found'); }
        function glimpseWord() { const word = getUnfoundWord(); if (!word) return; const positions = wordPositions.get(word); positions.forEach(p => { const cell = gridContainer.children[p.r * GRID_SIZE + p.c]; cell.classList.add('solution-path'); setTimeout(() => cell.classList.remove('solution-path'), 1000); }); }
        function findShortestWord() { const wordToFind = getUnfoundWord(true); if (!wordToFind) return; foundWords.add(wordToFind); document.getElementById('word-' + wordToFind).classList.add('found'); if (isGameActive && !isWarmupRound) updateScore(wordToFind.length * 10); }

        function endRound() {
            if (!isGameActive) return;
            isGameActive = false;
            clearInterval(gameTimer);

            if(isRisking && foundWords.size < WORD_COUNT) {
                riskedScore = 0;
                score = 0;
                updateScore(0);
                alert("Sajnos nem találtad meg az összes szót! A kockáztatott pontok elvesztek.");
                startNewRound(0, false);
                return;
            }

            timerDisplay.style.display = 'none';
            if(score + riskedScore > 0 && !isFreeRound) {
                endRoundChoices.style.display = 'flex';
            } else {
                if (score + riskedScore > 0) {
                    gameState.sodaPenz += Math.floor((score + riskedScore) / 10);
                    saveGameState();
                    updateSodaPenzDisplay();
                }
                newBoardBtn.style.display = 'block';
            }
            
            if(!megoldasBtn.disabled) {
                megoldasBtn.style.display = 'block';
            }
            renderRewards();
        }
        
        function scheduleNextBoard() {
            if (gameTimer) clearInterval(gameTimer);
            
            const checkTime = () => {
                const now = new Date();
                const remainingMilliseconds = nextBoardDate - now;

                if (remainingMilliseconds <= 0 && isGameActive) {
                    endRound();
                    return;
                }

                if(isGameActive) {
                    const minutes = Math.floor(remainingMilliseconds / 60000);
                    const seconds = Math.floor((remainingMilliseconds % 60000) / 1000);

                    if(isFreeRound) {
                        const targetTime = nextBoardDate.toLocaleTimeString('hu-HU', { hour: '2-digit', minute: '2-digit' });
                        timerDisplay.textContent = `Bemelegítő Kör (Éles játék: ${targetTime}-kor)`;
                        timerDisplay.classList.add('warmup-round');
                    } else {
                        timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        timerDisplay.classList.remove('warmup-round');
                    }

                    if (remainingMilliseconds <= 60000 && !megoldasBtn.disabled) {
                        megoldasBtn.style.display = 'block';
                    } else if (!megoldasBtn.disabled) {
                        megoldasBtn.style.display = 'none';
                    }
                }
            };

            checkTime();
            gameTimer = setInterval(checkTime, 1000);
        }

        function updateSodaHuntUI() {
            let allCollected = SODA_LETTERS.every(letter => collectedSodaLetters.has(letter));
            
            sodaHuntLettersContainer.querySelectorAll('span').forEach(span => {
                const letter = span.dataset.letter;
                if (collectedSodaLetters.has(letter)) {
                    span.classList.add('collected');
                } else {
                    span.classList.remove('collected');
                }
            });

            if (allCollected) {
                sodaHuntClaimBtn.style.display = 'block';
                sodaHuntLettersContainer.style.display = 'none';
            } else {
                sodaHuntClaimBtn.style.display = 'none';
                sodaHuntLettersContainer.style.display = 'flex';
            }
            
            if (activePowerUp && activePowerUp.expires > Date.now()) {
                activePowerupDisplay.textContent = `Aktív bónusz: ${activePowerUp.desc}`;
            } else {
                activePowerupDisplay.textContent = '';
            }
        }
        
        function claimSodaReward() {
            const powerups = [
                { type: 'double_points', desc: 'Pontduplázó' },
                { type: 'bonus_rain', desc: 'Bónusz Eső' }
            ];
            const randomPowerup = powerups[Math.floor(Math.random() * powerups.length)];

            activePowerUp = {
                type: randomPowerup.type,
                expires: Date.now() + 24 * 60 * 60 * 1000,
                desc: randomPowerup.desc
            };
            
            collectedSodaLetters.clear();
            updateSodaHuntUI();
            saveGameState();
            alert(`Gratulálunk! Egy "${activePowerUp.desc}" bónuszt kaptál 24 órára!`);
        }
        
        function updateSodaPenzDisplay() {
            sodaPenzBalance.textContent = gameState.sodaPenz;
        }

        function saveGameState() {
            const fullGameState = {
                ...gameState,
                collectedLetters: Array.from(collectedSodaLetters),
                activePowerUp: activePowerUp
            };
            localStorage.setItem('sodaGameState', JSON.stringify(fullGameState));
        }

        function loadGameState() {
            const savedState = localStorage.getItem('sodaGameState');
            if (savedState) {
                const loadedState = JSON.parse(savedState);
                gameState.sodaPenz = loadedState.sodaPenz || 0;
                gameState.upgrades = loadedState.upgrades || { point_multiplier: 0, discount: 0 };
                gameState.elixirs = loadedState.elixirs || { double_points: 0, magnet: 0 };
                
                collectedSodaLetters = new Set(loadedState.collectedLetters);
                
                if (loadedState.activePowerUp && loadedState.activePowerUp.expires > Date.now()) {
                    activePowerUp = loadedState.activePowerUp;
                } else {
                    activePowerUp = { type: null, expires: 0, desc: '' };
                }
            }
            updateSodaPenzDisplay();
            updateSodaHuntUI();
            renderPiac();
        }

    </script>
</body>
</html>
